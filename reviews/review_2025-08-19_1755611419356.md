**Overall Review Summary:**
- **Total Issues Found:** 15
- **Critical Issues:** 6 (Missing backend synchronization for file deletion, non-functional download button, non-functional quick action buttons, server-side data persistence bug, server-side missing `await`, inconsistent/incorrect ID generation on server)
- **Code Quality Score:** 6/10
- **Approval Status:** NEEDS_CHANGES
- **Key Recommendations:**
    1.  **Implement Robust File Management (Backend & Frontend):** Crucially, the server needs to persistently store uploaded files and generate a unique `fileId` (UUID) for each. This `fileId` must be returned to the client upon upload. A dedicated backend endpoint (`DELETE /upload/:fileId`) is required for file deletion to ensure data consistency, and a `GET /download/:fileId` endpoint is needed for file retrieval. The client must then use these server-provided IDs for all file operations (display, delete, download).
    2.  **Activate Core UI Functionality:** The "Download" button for files and the "New Chat", "Export Chat", and "Clear History" buttons are currently non-functional. These are essential user interactions and must have their `onClick` handlers fully implemented to provide the expected user experience.
    3.  **Ensure Dynamic UI Content & Unique IDs:** Replace all hardcoded UI elements (e.g., "UserName", static timestamps, "Recent Activity") with dynamic data reflecting actual application state. Transition away from `Date.now()` for generating client-side IDs to ensure uniqueness and stability, especially for React's `key` prop, preferably by using IDs provided by the backend for persisted data.

---

### File-by-File Review

**File:** `client/src/screens/Dashboard.jsx`
**Line(s):** 1, 20
- **Issue Type:** STYLE / BUG
  **Description:** The `useState` and `useEffect` imports are duplicated. They are imported once on line 1 from "react" and again on line 20. This is redundant and can lead to slight confusion or, in rare build configurations, unexpected behavior.
  **Line(s) to Fix:** 20
  **Current Code:**
  ```javascript
  import React, { useState, useEffect } from "react";
  // ... other imports ...
  import { useEffect, useState } from "react";
  ```
  **Suggested Fix:** Merge the imports into a single statement and remove the redundant line.
  ```javascript
  import React, { useState, useEffect } from "react";
  // ... other imports ...
  // Remove line 20 entirely
  ```
  **Priority:** MEDIUM

**Line(s):** 48, 70, 103
- **Issue Type:** LOGIC / BUG / MAINTAINABILITY
  **Description:** IDs for chat messages (lines 48, 70) and newly uploaded files (line 103) are generated using `Date.now()` and `Date.now() + 1`. This method does not guarantee unique IDs, especially if multiple messages or file uploads occur within the same millisecond or rapidly. This can lead to collisions, which are problematic for React's `key` prop (used on lines 240 and 291). Stable and unique keys are crucial for React to efficiently re-render lists and avoid issues like incorrect component state being retained or unexpected UI behavior. For files, the ID should ideally come from the server.
  **Line(s) to Fix:** 48, 70, 103
  **Current Code:**
  ```javascript
  // Line 48
  id: Date.now(),
  // Line 70
  id: Date.now() + 1,
  // Line 103
  id: Date.now(),
  ```
  **Suggested Fix:** Use a more robust ID generation strategy. For client-side elements that don't need global uniqueness across sessions, a simple incrementing counter managed in state is effective and reliable. For entities that are persisted (like files), the backend should generate a unique ID (e.g., UUID) and return it.
  ```javascript
  // Example for local chat messages (assuming no backend persistence for chat history):
  // Add a state variable for the next available ID:
  // const [nextLocalId, setNextLocalId] = useState(2); // Start after initial AI message ID: 1

  // Inside handleSendMessage for userMessage:
  // const userMessage = {
  //   id: nextLocalId,
  //   type: "user",
  //   content: message,
  //   timestamp: new Date().toLocaleTimeString("en-US", { hour12: false, hour: "2-digit", minute: "2-digit" }),
  // };
  // setNextLocalId(prev => prev + 1);
  // setChatMessages((prev) => [...prev, userMessage]);

  // Inside handleSendMessage for aiMessage:
  // const aiMessage = {
  //   id: nextLocalId,
  //   type: "ai",
  //   content: response.data.data.reply,
  //   timestamp: new Date().toLocaleTimeString("en-US", { hour12: false, hour: "2-digit", minute: "2-digit" }),
  // };
  // setNextLocalId(prev => prev + 1);
  // setChatMessages((prev) => [...prev, aiMessage]);

  // For files, the ID should come from the backend response. (See related server-side issue)
  // Inside handleFileUpload for newFile:
  // const newFile = {
  //   id: response.data.fileId, // Use the unique ID generated by the backend
  //   name: response.data.fileName,
  //   type: response.data.fileType,
  //   size: response.data.fileSize,
  //   uploadTime: response.data.uploadTime || new Date().toLocaleTimeString("en-US", { hour12: false, hour: "2-digit", minute: "2-digit" }),
  // };
  // setFiles((prev) => [...prev, newFile]);
  ```
  **Priority:** MEDIUM

**Line(s):** 106
- **Issue Type:** LOGIC / UX
  **Description:** The file name is arbitrarily truncated to its first 6 characters using `substring(0, 6)`. This often results in unreadable or misleading file names (e.g., "document.pdf" becoming "DOCUME"), reducing clarity and usability for the user.
  **Line(s) to Fix:** 106
  **Current Code:**
  ```javascript
  name: file.name.toUpperCase().substring(0, 6),
  ```
  **Suggested Fix:** Display the full file name. If space is a concern, implement a more intelligent truncation (e.g., "document...pdf") or provide a tooltip for the full name on hover. This `name` should ideally come from the backend's response after upload.
  ```javascript
  name: file.name, // Display full name for better UX
  // OR for smarter truncation (example, actual implementation might vary for consistency):
  // name: file.name.length > 20 ? `${file.name.substring(0, 17)}...${file.name.split('.').pop()}` : file.name,
  ```
  **Priority:** MEDIUM

**Line(s):** 115, 118, 368, 391-394
- **Issue Type:** LOGIC / MAINTAINABILITY / UX
  **Description:** Several UI elements display hardcoded static values, such as "UserName", "12:33", and generic "Recent Activity" entries. These should be dynamic, reflecting actual user data, current time/last activity, and real-time events to provide a meaningful and engaging user experience.
  **Line(s) to Fix:** 115, 118, 368, 391-394
  **Current Code:**
  ```html
  // Line 115
  <span className="font-semibold">UserName</span>
  // Line 118
  <div className="bg-black text-white px-3 py-2 text-sm font-mono">12:33</div>
  // Line 368
  <span>Last message: 12:33</span>
  // Lines 391-394
  <h3 className="font-bold mb-3">Recent Activity</h3>
  <div className="bg-white border border-black p-3">
    <div className="text-xs text-gray-600 space-y-2">
      <div>• Document uploaded</div>
      <div>• AI analysis complete</div>
      <div>• Chat session started</div>
    </div>
  </div>
  ```
  **Suggested Fix:**
    *   For `UserName`, retrieve from an authentication context or prop (e.g., `<span className=\"font-semibold\">{user.name || \"Guest\"}</span>`).
    *   For timestamps (header and "Last message"), use `new Date().toLocaleTimeString(...)` to display the actual current time or the timestamp of the last chat message.
    *   For "Recent Activity", implement a mechanism to track and display actual events (e.g., using a state array for activities).
  ```javascript
  // Example for Current Time in header:
  // const [currentTime, setCurrentTime] = useState(new Date().toLocaleTimeString("en-US", { hour12: false, hour: "2-digit", minute: "2-digit" }));
  // useEffect(() => {
  //   const interval = setInterval(() => {
  //     setCurrentTime(new Date().toLocaleTimeString("en-US", { hour12: false, hour: "2-digit", minute: "2-digit" }));
  //   }, 60000); // Update every minute
  //   return () => clearInterval(interval);
  // }, []);
  // ...
  // <div className="bg-black text-white px-3 py-2 text-sm font-mono">{currentTime}</div>

  // Example for Last message timestamp:
  // const lastMessageTime = chatMessages.length > 0 ? chatMessages[chatMessages.length - 1].timestamp : "N/A";
  // ...
  // <span>Last message: {lastMessageTime}</span>

  // For Recent Activity, a new state variable (e.g., `recentActivities`) and logic to push activity strings would be needed.
  // Example render:
  // {recentActivities.map((activity, index) => <div key={index}>• {activity}</div>)}
  ```
  **Priority:** MEDIUM

**Line(s):** 158
- **Issue Type:** BUG / LOGIC / MAINTAINABILITY
  **Description:** The `removeFile` function only updates the client-side `files` state by filtering out the specified file. It does not send a corresponding request to the backend to delete the file from the server. This results in a desynchronization: files deleted on the client will reappear if the page is refreshed or the component remounts, as they still exist on the server. This is a critical data integrity issue.
  **Line(s) to Fix:** 158
  **Current Code:**
  ```javascript
  const removeFile = (fileId) => {
    setFiles((prev) => prev.filter((file) => file.id !== fileId));
  };
  ```
  **Suggested Fix:** Add an `axiosInstance.delete` call to the `removeFile` function, targeting the backend's file deletion endpoint. Update the client-side state only after a successful server response. (Requires the backend to implement a `DELETE /upload/:fileId` endpoint).
  ```javascript
  const removeFile = (fileId) => {
    // Assuming the backend has a delete endpoint like /upload/:fileId
    axiosInstance.delete(`/upload/${fileId}`)
      .then((response) => {
        if (response.data.success) {
          setFiles((prev) => prev.filter((file) => file.id !== fileId));
          notify("✅ File deleted successfully!", "success");
        } else {
          notify(response.data.message || "❌ Failed to delete file!", "error");
        }
      })
      .catch((error) => {
        console.error("File deletion error:", error);
        notify("❌ Failed to delete file! Make sure file ID is correct and backend is reachable.", "error");
      });
  };
  ```
  **Priority:** HIGH

**Line(s):** 214
- **Issue Type:** STYLE / UX
  **Description:** The loading spinner uses `border-b-2 border-black` which creates a quarter-circle animation. While functional, a more conventional and universally recognized spinner animation typically involves a full circle with one or more borders transparent or a different color (e.g., `border-2 border-gray-400 border-t-2 border-black`) to give a smoother, continuous rotation effect.
  **Line(s) to Fix:** 214
  **Current Code:**
  ```html
  <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-black mr-2"></div>
  ```
  **Suggested Fix:** Adjust the border styles for a more standard spinner appearance.
  ```html
  <div className="animate-spin rounded-full h-4 w-4 border-2 border-gray-400 border-t-2 border-black mr-2"></div>
  ```
  **Priority:** LOW

**Line(s):** 258
- **Issue Type:** BUG / LOGIC / UX
  **Description:** The "Download" button for uploaded files is rendered in the UI but currently has no `onClick` handler attached. This means it is purely decorative and provides no functional way for users to download the associated file. This is a core missing feature.
  **Line(s) to Fix:** 258
  **Current Code:**
  ```html
  <button
    className="p-1 hover:bg-black hover:text-white transition-colors"
    title="Download"
  >
    <Download className="h-3 w-3" />
  </button>
  ```
  **Suggested Fix:** Add an `onClick` handler that triggers the file download. This would typically involve constructing a download URL (e.g., `/api/download/${file.id}`) and opening it in a new tab or initiating a download via an `<a>` tag. (Requires the backend to implement a `GET /download/:fileId` endpoint).
  ```html
  <button
    onClick={() => {
      // Implement download logic here. Example:
      // window.open(`/download/${file.id}`, '_blank');
      // Replace file.id with the actual ID received from the backend on upload
      notify(`Downloading ${file.name}... (feature not yet fully implemented on backend)`, "info");
    }}
    className="p-1 hover:bg-black hover:text-white transition-colors"
    title="Download"
  >
    <Download className="h-3 w-3" />
  </button>
  ```
  **Priority:** HIGH

**Line(s):** 379, 382, 385
- **Issue Type:** BUG / LOGIC / UX
  **Description:** The "New Chat", "Export Chat", and "Clear History" buttons within the "Quick Actions" section are displayed but currently lack `onClick` handlers. As a result, they do not perform any actions when clicked, which will lead to a confusing and frustrating user experience.
  **Line(s) to Fix:** 379, 382, 385
  **Current Code:**
  ```html
  <button className="w-full p-2 border border-black hover:bg-black hover:text-white transition-colors text-sm">
    New Chat
  </button>
  <button className="w-full p-2 border border-black hover:bg-black hover:text-white transition-colors text-sm">
    Export Chat
  </button>
  <button className="w-full p-2 border border-black hover:bg-black hover:text-white transition-colors text-sm">
    Clear History
  </button>
  ```
  **Suggested Fix:** Implement appropriate `onClick` handlers for each button:
    *   **New Chat**: Reset `chatMessages` to initial state (e.g., just the welcome AI message) and potentially trigger a backend session reset.
    *   **Export Chat**: Implement logic to format `chatMessages` (e.g., as text or JSON) and trigger a file download.
    *   **Clear History**: Reset `chatMessages` (and `files` if a full session clear is desired) and trigger any necessary backend cleanup.
  ```html
  <button
    onClick={() => {
      setChatMessages([
        {
          id: 1, // Ensure this ID is consistent or regenerated if using `nextLocalId`
          type: "ai",
          content: "Hello! I've analyzed your uploaded documents. What would you like to know about them?",
          timestamp: new Date().toLocaleTimeString("en-US", { hour12: false, hour: "2-digit", minute: "2-digit" }),
        },
      ]);
      setFiles([]); // Optionally clear files as well for a "new session"
      notify("✅ New chat session started!", "success");
      // Consider an API call to reset backend session if relevant
    }}
    className="w-full p-2 border border-black hover:bg-black hover:text-white transition-colors text-sm"
  >
    New Chat
  </button>
  <button
    onClick={() => {
      // Logic to format chatMessages (e.g., as a text file) and trigger a download
      notify("⏳ Export chat feature is not yet implemented.", "info");
    }}
    className="w-full p-2 border border-black hover:bg-black hover:text-white transition-colors text-sm"
  >
    Export Chat
  </button>
  <button
    onClick={() => {
      setChatMessages([
        {
          id: 1, // Ensure this ID is consistent or regenerated if using `nextLocalId`
          type: "ai",
          content: "Hello! I've analyzed your uploaded documents. What would you like to know about them?",
          timestamp: new Date().toLocaleTimeString("en-US", { hour12: false, hour: "2-digit", minute: "2-digit" }),
        },
      ]);
      setFiles([]); // Optionally clear files as well
      notify("✅ Chat history cleared!", "success");
      // Consider an API call to clear backend session data
    }}
    className="w-full p-2 border border-black hover:bg-black hover:text-white transition-colors text-sm"
  >
    Clear History
  </button>
  ```
  **Priority:** HIGH

**File:** `server/src/controllers/upload.controller.js`
**Line(s):** 7
- **Issue Type:** STYLE / MAINTAINABILITY
  **Description:** The `db` import from `../database/sqlLite.db.js` is declared but never used within this file. Unused imports clutter the code and can sometimes indicate dead code or incomplete refactoring.
  **Line(s) to Fix:** 7
  **Current Code:**
  ```javascript
  import { db, runQuery } from "../database/sqlLite.db.js";
  ```
  **Suggested Fix:** Remove the unused `db` import.
  ```javascript
  import { runQuery } from "../database/sqlLite.db.js";
  ```
  **Priority:** LOW

**Line(s):** 10-13
- **Issue Type:** BUG / LOGIC
  **Description:** The `runQuery` call on line 10 to fetch `userId` is not `await`ed. This means the `user` variable will hold a Promise object, not the resolved user data. Consequently, the `if (!user)` check on line 20 will likely always evaluate to `false` (as a Promise is a truthy object), even if no user is found. This can lead to subsequent errors when attempting to access `user.userId` or other properties, as the Promise has not resolved yet.
  **Line(s) to Fix:** 10
  **Current Code:**
  ```javascript
  const user = runQuery("SELECT userId FROM userData WHERE email = ? LIMIT 1", [
    req.user.email,
  ]);
  ```
  **Suggested Fix:** Add `await` before the `runQuery` call.
  ```javascript
  const user = await runQuery("SELECT userId FROM userData WHERE email = ? LIMIT 1", [
    req.user.email,
  ]);
  ```
  **Priority:** HIGH

**Line(s):** 15, 37, 43-45
- **Issue Type:** STYLE / DEBUG
  **Description:** There are several `console.log` statements used for debugging purposes. While useful during development, these should be removed from production code as they can leak sensitive information, reduce performance, and clutter server logs. The `logger.info` calls are appropriate for production.
  **Line(s) to Fix:** 15, 37, 43-45
  **Current Code:**
  ```javascript
  // Line 15
  console.log("User found:", user);
  // Line 37
  console.log("🧩 Vector inserted with ID:", vectorResult.id);
  // Lines 43-45
  // console.log(typeof vectorResult.id);
  // console.log(typeof user.userId);
  // console.log(typeof req.file.path);
  ```
  **Suggested Fix:** Remove or comment out these `console.log` statements.
  ```javascript
  // No change, remove the lines
  // Alternatively, for future debugging, consider using logger.debug if available and enabled based on environment.
  ```
  **Priority:** LOW

**Line(s):** 40, 42, 50-54, 62-67
- **Issue Type:** BUG / LOGIC / MAINTAINABILITY
  **Description:**
    1.  **File Persistence:** The `filePath` (`req.file.path`) stored in the `files` table (line 52) is the temporary path where Multer initially saves the file. This file will likely be deleted after the request is processed, making it inaccessible for future operations like downloading or re-analyzing. Files intended for persistence must be moved to a permanent storage location.
    2.  **File ID Generation & Association:** Currently, the server doesn't generate a unique ID for the *overall PDF file*. Instead, it iterates through pages, creates vectors, and inserts a record into the `files` table for *each page's vector* with the same `filePath` (temporary Multer path). This structure is problematic:
        *   There's no single `fileId` that represents the entire uploaded PDF.
        *   The client needs a `fileId` to uniquely identify the PDF for actions like download or delete.
        *   Storing `filePath` and `chatId` per vector is redundant if they apply to the whole document.
    3.  **`chatId` Logic:** A `chatId` is generated using `uuidv4()` for *each page* and inserted into the `files` table (line 40). If `chatId` is meant to represent a chat session linked to a *document*, it should be one `chatId` per document, not one per page.
    4.  **Response to Client:** The `handlePdfUpload` response on lines 62-67 does not return sufficient information (like a unique `fileId`, `fileName`, `fileSize`) to the client for it to correctly display and manage the uploaded file.
  **Line(s) to Fix:** 40, 42, 50-54, 62-67
  **Current Code:**
  ```javascript
  // Line 40
  const chatId = uuidv4();
  // Line 42 (part of SQL)
  // VALUES (?, ?, ?, ?) <- these are user.userId, req.file.path, vectorResult.id, chatId
  // Lines 50-54 (SQL insert)
  await runQuery(
    `
    INSERT INTO files (userId, filePath, vectorId, chatId)
    VALUES (?, ?, ?, ?)
  `,
    [user.userId, req.file.path, vectorResult.id, chatId]
  );
  // Lines 62-67 (Response)
  return res.json({
    success: true,
    count: addResults.length,
    message: "PDF uploaded and processed successfully",
  });
  ```
  **Suggested Fix:**
    1.  **Move File to Permanent Storage:** Before processing pages, move `req.file.path` to a permanent, accessible directory. Store this permanent path.
    2.  **Generate a Single File ID:** Generate a `fileId` (UUID) for the entire PDF document *once* at the beginning of `handlePdfUpload`.
    3.  **Refactor Database Schema/Insert:** The `files` table should store details about the *file itself* (e.g., `fileId`, `userId`, `permanentFilePath`, `originalFileName`, `fileSize`, `uploadTime`, `chatSessionId`). The `vectorId` should likely be in a separate `vectors` table that links back to `fileId`.
    4.  **Associate Vectors with File ID:** When adding vectors, link them to this single `fileId`.
    5.  **Return Comprehensive File Data:** The response should include the `fileId` and other metadata the client needs for display and future operations.

  ```javascript
  // Add path dependency (e.g., import path from 'path'; import fs from 'fs/promises';)
  // And a configuration for upload directory (e.g., const UPLOAD_DIR = './uploads';)
  export const handlePdfUpload = async (req, res) => {
    const user = await runQuery("SELECT userId FROM userData WHERE email = ? LIMIT 1", [
      req.user.email,
    ]);

    if (!user) {
      // Ensure this error is thrown after await, or handle it properly.
      throw new ApiError(404, "User not found", [req.user.email]);
    }

    // Define permanentFilePath outside try-catch for cleanup in catch block
    let permanentFilePath; 

    try {
      logger.info("Uploaded file:", req.file);

      // 1. Generate a single UUID for the entire file
      const fileId = uuidv4();
      const originalFileName = req.file.originalname;
      const fileExtension = path.extname(originalFileName);
      const permanentFileName = `${fileId}${fileExtension}`;
      const UPLOAD_DIR = './uploads'; // Define this properly, e.g., from config
      permanentFilePath = path.join(UPLOAD_DIR, permanentFileName); 

      // Ensure UPLOAD_DIR exists
      await fs.mkdir(UPLOAD_DIR, { recursive: true });

      // 2. Move the temporary file to a permanent location
      await fs.rename(req.file.path, permanentFilePath);
      logger.info(`File moved to permanent storage: ${permanentFilePath}`);

      // 3. Store initial file metadata in DB (e.g., in a 'documents' table)
      // This assumes a new table structure or modifying existing 'files' table
      // Example for a 'documents' table:
      const chatSessionId = uuidv4(); // One chat session per document
      await runQuery(
        `INSERT INTO documents (documentId, userId, filePath, originalFileName, fileSize, uploadTime, chatSessionId, fileType)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
        [fileId, user.userId, permanentFilePath, originalFileName, req.file.size, Date.now(), chatSessionId, req.file.mimetype]
      );
      logger.info(`Document metadata inserted for fileId: ${fileId}`);

      // 4. Chunk the PDF into pages
      // Use the permanent path for chunkPdf if it relies on file system access
      const pages = await chunkPdf(permanentFilePath);

      // 5. Process each page and link vectors to the main document ID
      const addResults = await Promise.all(
        pages.map(async (page) => {
          const embedding = await getEmbeddings(page.pageContent);
          const vectorId = uuidv4(); // Unique ID for each vector

          const vectorResult = await addVector({
            id: vectorId,
            embedding,
            text: page.pageContent,
            metadata: { ...page.metadata, documentId: fileId }, // Link vector to the document
          });

          // Store vector-document relationship if your schema requires it, or if 'files' table
          // now means 'vector_chunks' with a document_id foreign key.
          // Example: INSERT INTO document_vectors (documentId, vectorId) VALUES (?, ?);
          // Assuming `files` table is now `vectors_metadata` or similar, linking to `documents`
          await runQuery(
            `INSERT INTO vectors_metadata (vectorId, documentId, pageNumber) VALUES (?, ?, ?)`,
            [vectorId, fileId, page.metadata.loc.pageNumber]
          );

          return vectorResult.id;
        })
      );

      // 6. Response to client with the new fileId and details
      logger.info(`Added ${addResults.length} page vectors successfully for fileId: ${fileId}.`);
      return res.json({
        success: true,
        fileId: fileId, // Crucial for client to identify the file
        fileName: originalFileName,
        fileSize: req.file.size,
        fileType: req.file.mimetype,
        uploadTime: new Date().toLocaleTimeString("en-US", { hour12: false, hour: "2-digit", minute: "2-digit" }),
        message: "PDF uploaded and processed successfully",
      });
    } catch (error) {
      logger.error("❌ Error in PDF upload handling:", error);
      // Clean up uploaded file if an error occurs after moving it
      if (permanentFilePath) {
        try { await fs.unlink(permanentFilePath); } catch (cleanupError) { logger.error("Failed to clean up file:", cleanupError); }
      }
      throw new ApiError(500, "Failed to process PDF upload", [error.message]);
    }
  };
  ```
  **Priority:** HIGH

**Line(s):** 71-76
- **Issue Type:** LOGIC / MAINTAINABILITY
  **Description:** The `getUploadedFiles` endpoint currently only retrieves `fileId` and `filePath` from the `files` table. The client-side `Dashboard.jsx` (around line 98 and 230) expects more detailed file information like `name` (original filename), `type`, `size`, and `uploadTime` to display comprehensive file cards. This information is currently not stored or retrieved, leading to incomplete UI data.
  **Line(s) to Fix:** 71-76
  **Current Code:**
  ```javascript
  const files = await runQuery(
    "SELECT fileId, filePath FROM files WHERE userId = ?",
    [user.userId]
  );
  ```
  **Suggested Fix:** The `files` table (or a new `documents` table as suggested in the previous point) should store `originalFileName`, `fileSize`, `uploadTime`, `fileType`. The `getUploadedFiles` query should then select these additional columns.
  ```javascript
  // Assuming a 'documents' table with more metadata
  const files = await runQuery(
    "SELECT documentId AS id, originalFileName AS name, fileSize AS size, fileType AS type, uploadTime FROM documents WHERE userId = ?",
    [user.userId]
  );
  ```
  **Priority:** MEDIUM

**No Line(s):** (New Endpoint)
- **Issue Type:** BUG / LOGIC / MAINTAINABILITY
  **Description:** There is no API endpoint to handle the deletion of uploaded files from the server. The client-side `removeFile` function (in `Dashboard.jsx`) attempts to remove files, but without a corresponding backend endpoint, the files remain on the server, leading to data inconsistency and eventual storage bloat. This is a critical missing piece of functionality.
  **Line(s) to Fix:** N/A (requires new function and route)
  **Current Code:** (No existing code for file deletion endpoint)
  **Suggested Fix:** Implement a new controller function and route (e.g., `DELETE /api/upload/:fileId`) to handle file deletion. This function should:
    1.  Validate the `fileId`.
    2.  Retrieve the `filePath` from the database.
    3.  Delete associated vectors from ChromaDB (by `documentId`).
    4.  Delete the file record from the database.
    5.  Delete the actual file from disk using `fs.unlink`.
    6.  Return a success or failure response.
  ```javascript
  // server/src/controllers/upload.controller.js
  // Make sure to import fs/promises and any necessary ChromaDB deletion functions
  // import { deleteVectorByDocumentId } from "../services/chromadb.service.js"; // Assume this function exists
  // import fs from 'fs/promises'; // Add this import

  export const deleteFile = async (req, res) => {
    const { fileId } = req.params; // Expect fileId from URL parameter
    const user = await runQuery(
      "SELECT userId FROM userData WHERE email = ? LIMIT 1",
      [req.user.email]
    );

    if (!user) {
      throw new ApiError(404, "User not found", [req.user.email]);
    }

    let filePathToDelete; // Declare outside try-catch for cleanup

    try {
      // 1. Get file path and ensure user owns the file
      const fileRecord = await runQuery(
        "SELECT filePath FROM documents WHERE documentId = ? AND userId = ?",
        [fileId, user.userId]
      );

      if (!fileRecord || fileRecord.length === 0) {
        throw new ApiError(404, "File not found or not authorized", [fileId]);
      }

      filePathToDelete = fileRecord[0].filePath;

      // 2. Delete associated vectors from ChromaDB (assuming one documentId maps to multiple vector IDs)
      // This assumes `deleteCollectionByDocumentId` or similar exists in your chromadb service
      // If collection is per user or global, you might need a different strategy.
      // If vectors are stored in a single collection and filtered by documentId metadata, use:
      await deleteVectorsByDocumentId(fileId); // Implement this in chromadb.service.js
      logger.info(`Vectors for document ${fileId} deleted from ChromaDB.`);

      // 3. Delete related vector_metadata records from database
      await runQuery("DELETE FROM vectors_metadata WHERE documentId = ?", [fileId]);
      logger.info(`Vector metadata for document ${fileId} deleted from database.`);

      // 4. Delete file record from database
      await runQuery("DELETE FROM documents WHERE documentId = ?", [fileId]);
      logger.info(`Document record ${fileId} deleted from database.`);

      // 5. Delete the physical file from storage
      await fs.unlink(filePathToDelete);
      logger.info(`Physical file ${filePathToDelete} deleted.`);

      return res.json({ success: true, message: "File deleted successfully" });
    } catch (error) {
      logger.error("❌ Error in file deletion:", error);
      // Attempt to clean up physical file if it was moved but DB deletion failed
      if (filePathToDelete && error.code !== 'ENOENT') { // ENOENT means file not found, so no need to try unlink again
        try { await fs.unlink(filePathToDelete); logger.warn(`Attempted to clean up partially deleted file: ${filePathToDelete}`); }
        catch (cleanupError) { logger.error("Failed to clean up file after error:", cleanupError); }
      }
      throw new ApiError(500, "Failed to delete file", [error.message]);
    }
  };

  // Add this to your router (e.g., server/src/routes/upload.routes.js)
  // router.delete("/:fileId", authenticateUser, deleteFile);
  ```
  **Priority:** HIGH

**No Line(s):** (New Endpoint)
- **Issue Type:** BUG / LOGIC / MAINTAINABILITY
  **Description:** There is no API endpoint to facilitate the download of uploaded files. The client-side "Download" button is non-functional because it has no server endpoint to request the file from.
  **Line(s) to Fix:** N/A (requires new function and route)
  **Current Code:** (No existing code for file download endpoint)
  **Suggested Fix:** Implement a new controller function and route (e.g., `GET /api/download/:fileId`) to handle file downloads. This function should:
    1.  Validate the `fileId`.
    2.  Retrieve the `filePath` and `originalFileName` from the database.
    3.  Set appropriate headers (`Content-Disposition`, `Content-Type`).
    4.  Send the file using `res.download` or `res.sendFile`.
  ```javascript
  // server/src/controllers/upload.controller.js
  // Ensure path is imported: import path from 'path';
  // Ensure fs/promises is imported: import fs from 'fs/promises';

  export const downloadFile = async (req, res) => {
    const { fileId } = req.params;
    const user = await runQuery(
      "SELECT userId FROM userData WHERE email = ? LIMIT 1",
      [req.user.email]
    );

    if (!user) {
      throw new ApiError(404, "User not found", [req.user.email]);
    }

    try {
      const fileRecord = await runQuery(
        "SELECT filePath, originalFileName FROM documents WHERE documentId = ? AND userId = ?",
        [fileId, user.userId]
      );

      if (!fileRecord || fileRecord.length === 0) {
        throw new ApiError(404, "File not found or not authorized", [fileId]);
      }

      const filePath = fileRecord[0].filePath;
      const fileName = fileRecord[0].originalFileName;

      // Ensure file exists before attempting to send
      await fs.access(filePath); // Checks if file exists and process has read permissions

      res.download(filePath, fileName, (err) => {
        if (err) {
          logger.error("❌ Error downloading file:", err);
          // Check if headers were already sent to avoid 'Cannot set headers after they are sent'
          if (!res.headersSent) {
            res.status(500).json({ success: false, message: "Failed to download file" });
          }
        }
      });
    } catch (error) {
      logger.error("❌ Error in file download handling:", error);
      throw new ApiError(500, "Failed to download file", [error.message]);
    }
  };

  // Add this to your router (e.g., server/src/routes/upload.routes.js)
  // router.get("/download/:fileId", authenticateUser, downloadFile);
  ```
  **Priority:** HIGH

**File:** `server/src/routes/upload.route.js`
**Line(s):** 8-9
- **Issue Type:** STYLE / MAINTAINABILITY
  **Description:** The `getUploadedFiles` import is placed inside the router definition block, which is unconventional and can cause linting issues or confusion. It should be with other imports at the top of the file. Also, the `get` route for `/` is missing the `verifyJwtToken` middleware, which is inconsistent with the `post` route and potentially a security oversight.
  **Line(s) to Fix:** 8-9
  **Current Code:**
  ```javascript
  router.post("/", verifyJwtToken, upload.single("pdfFile"), handlePdfUpload);
  import { getUploadedFiles } from "../controllers/upload.controller.js";

  router.get("/", getUploadedFiles);
  ```
  **Suggested Fix:** Move the import statement to the top of the file, alongside other imports, and apply the `verifyJwtToken` middleware to the `get` route. Additionally, ensure new controller functions for delete and download are imported and their routes are added.
  ```javascript
  import express from "express";
  import {
    handlePdfUpload,
    getUploadedFiles,
    // Add these when implemented in controller:
    deleteFile,    // Uncomment/add this
    downloadFile   // Uncomment/add this
  } from "../controllers/upload.controller.js";
  import { upload } from "../services/multer.service.js";
  import { verifyJwtToken } from "../middlewares/auth.middleware.js";

  const router = express.Router();

  router.post("/", verifyJwtToken, upload.single("pdfFile"), handlePdfUpload);
  router.get("/", verifyJwtToken, getUploadedFiles); // Added verifyJwtToken

  // Add routes for new endpoints after implementing their controllers:
  router.delete("/:fileId", verifyJwtToken, deleteFile); // Add this route
  router.get("/download/:fileId", verifyJwtToken, downloadFile); // Add this route
  ```
  **Priority:** LOW