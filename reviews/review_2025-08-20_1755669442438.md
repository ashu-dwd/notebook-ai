### Overall Review Summary:
This Pull Request introduces significant features, including user authentication, file upload/management, and AI-powered chat. While the overall architecture demonstrates a good starting point, there are several critical issues that need to be addressed before merging. These primarily revolve around **robust error handling and asynchronous operations**, **data consistency (especially regarding file storage and unique IDs)**, **security vulnerabilities (hardcoded secrets, unauthenticated endpoints)**, and **UI/backend synchronization** for file management functionalities.

-   **Total Issues Found:** 25
-   **Critical Issues:** 10 (Security, Major Bugs, Data Inconsistency)
-   **Code Quality Score:** 4/10
-   **Approval Status:** NEEDS_CHANGES
-   **Key Recommendations:**
    1.  **Prioritize Backend Reliability & Security:**
        *   **Fix all missing `await` keywords and implement comprehensive `try...catch` blocks** for *all* asynchronous database and external API calls across controllers and services to prevent application crashes and ensure proper flow.
        *   **Move all sensitive API keys and secrets (e.g., `CHROMADB_API_KEY`, `JWT_SECRET`) to environment variables** and ensure they are accessed securely.
        *   **Implement proper file persistence and lifecycle management on the server:** Uploaded files must be moved from temporary storage to a permanent location, assigned a unique ID, and correctly deleted from disk, SQLite, and ChromaDB when a deletion request is made.
        *   **Secure all user-specific API endpoints** by ensuring `verifyJwtToken` middleware is applied.
    2.  **Ensure Frontend-Backend Synchronization & Functionality:**
        *   **Standardize file object structures** returned by the backend for both file uploads and listings. The backend must provide a consistent `fileId`, `name`, `size`, `type`, and `uploadedAt` timestamp. The frontend should then consistently use these server-provided IDs and details for displaying, deleting, and downloading files.
        *   **Implement the missing functionality for core UI elements** such as the "Download" button for files and the "New Chat", "Export Chat", and "Clear History" buttons in the dashboard.
    3.  **Enhance Code Quality & Maintainability:**
        *   Remove all `console.log` and commented-out debugging statements from production code. Use the `logger` utility consistently for all server-side logging.
        *   Correct all typos in filenames and code.
        *   Address all duplicate and unused imports.

---

### File-by-File Review

**File:** `client/src/screens/Dashboard.jsx`
**Line(s):** 1, 20
- **Issue Type:** STYLE / BUG
  **Description:** The `useState` and `useEffect` React hooks are imported twice. They are imported once on line 1 from "react" and again on line 20. This is redundant and can lead to slight confusion or, in rare build configurations, unexpected behavior.
  **Line(s) to Fix:** 20
  **Current Code:**
  ```javascript
  import React, { useState, useEffect, useRef } from "react";
  // ... other imports ...
  import { useEffect, useState } from "react";
  ```
  **Suggested Fix:** Merge the imports into a single statement and remove the redundant line.
  ```javascript
  import React, { useState, useEffect, useRef } from "react";
  // ... other imports ...
  // Remove line 20 entirely
  ```
  **Priority:** MEDIUM

**Line(s):** 48, 70, 103, 166, 180
- **Issue Type:** LOGIC / BUG / MAINTAINABILITY
  **Description:** IDs for client-side chat messages (lines 166, 180) and the initial welcome message (line 103, 110) are generated using `Date.now()` or a hardcoded `1`. `Date.now()` is not guaranteed unique if multiple actions occur within the same millisecond. Hardcoded `id: "welcome"` or `id: 1` might lead to issues if the component remounts or multiple instances exist. While `chatId` and `fileId` from the backend are better, inconsistent client-side ID generation can cause problematic `key` props for React lists (used on lines 240 and 291), leading to rendering issues or incorrect component state updates.
  **Line(s) to Fix:** 48, 70, 103, 110, 166, 180
  **Current Code:**
  ```javascript
  // Line 48: id: `user-${chat.chatId}`, (from backend)
  // Line 70: id: `ai-${chat.chatId}`, (from backend)
  // Line 103: id: "welcome",
  // Line 110: id: "welcome",
  // Line 166: id: `user-${Date.now()}`,
  // Line 180: id: `ai-${Date.now()}`,
  ```
  **Suggested Fix:** Use a robust client-side ID generation strategy like `uuid` for local/temporary items. Ensure backend-provided IDs are unique and consistently used for persisted items.
  ```javascript
  // Add import: import { v4 as uuidv4 } from 'uuid';

  // For initial AI message, to ensure uniqueness:
  // Line 103:
  transformedMessages.push({
    id: uuidv4(), // Use uuidv4() for uniqueness
    type: "ai",
    content: "Hello! I've analyzed your uploaded documents. What would you like to know about them?",
    timestamp: getCurrentTimestamp(),
  });
  // Line 110: Similarly for the fallback welcome message.
  setChatMessages([
    {
      id: uuidv4(),
      type: "ai",
      content: "Hello! I've analyzed your uploaded documents. What would you like to know about them?",
      timestamp: getCurrentTimestamp(),
    },
  ]);

  // In handleSendMessage:
  // Line 166:
  const userMessage = {
    id: `user-${uuidv4()}`, // Use uuidv4() for better uniqueness
    type: "user",
    content: message,
    timestamp: getCurrentTimestamp(),
  };
  // Line 180:
  const aiMessage = {
    id: `ai-${uuidv4()}`, // Use uuidv4() for better uniqueness
    type: "ai",
    content: response.data.response,
    timestamp: getCurrentTimestamp(),
  };
  ```
  **Priority:** MEDIUM

**Line(s):** 98-100, 199-202, 240
- **Issue Type:** BUG / LOGIC / MAINTAINABILITY
  **Description:** The `files` state array and its rendering logic suffer from inconsistent data structure.
    1.  **Fetched Files (from `axiosInstance.get("/upload")`):** These files (`response.data.files`) currently contain `fileId` and `filePath`. The rendering logic (lines 199-202) *derives* `fileName` and `fileType` from `file.filePath`, but hardcodes `fileSize` and `uploadTime` to "N/A" because this data is not returned by the backend. `filePath` should ideally not be exposed to the frontend as it's a server-side temporary path.
    2.  **Newly Uploaded Files (from `handleFileUpload`):** The current client code doesn't explicitly add newly uploaded files to state until `axiosInstance.get("/upload")` is called again. The backend response to `/upload` (POST) also does not return sufficient information about the newly uploaded file for the client to directly add it to the list.
  This inconsistency leads to incomplete UI display for fetched files and an inefficient re-fetch process after upload.
  **Line(s) to Fix:** 98-100, 199-202, 240
  **Current Code:**
  ```javascript
  // Line 98-100 (Fetched files)
  setFiles(response.data.files); // response.data.files contains { fileId, filePath }

  // Lines 199-202 (File rendering)
  const fileName = file.filePath || file.name;
  const fileType = fileName.split(".").pop()?.toUpperCase() || "FILE";
  const fileSize = file.fileSize || "N/A"; // file.fileSize is undefined for fetched files
  const uploadTime = file.uploadedAt ? formatTimestamp(file.uploadedAt) : "N/A"; // file.uploadedAt is undefined
  // Line 240: key={file.fileId}
  ```
  **Suggested Fix:** The backend's `getUploadedFiles` endpoint should return comprehensive file metadata (e.g., `fileId`, `originalFileName`, `fileSize`, `fileType`, `uploadedAt` as proper ISO timestamps). The frontend should then directly use these properties for rendering. Additionally, the backend's `handlePdfUpload` (POST) should return the full, persisted file object upon successful upload, which the frontend can directly add to its state without a full re-fetch.
  ```javascript
  // Frontend Update (Dashboard.jsx)
  // Lines 98-100 (Assuming backend now returns file objects with {fileId, name, size, type, uploadedAt})
  useEffect(() => {
    // ...
    axiosInstance
      .get("/upload")
      .then((response) => {
        if (response.data.success) {
          setFiles(response.data.files); // Now contains comprehensive data
        } else {
          notify(response.data.message || "❌ Failed to fetch files!", "error");
        }
      })
      .catch((error) => {
        console.error("Error fetching files:", error);
        notify("❌ Failed to fetch files!", "error");
      });
  }, []); // Re-run only on navigate if files are transient, or only once if files are static.

  // Lines 199-202 (File mapping for rendering)
  {files.map((file) => {
    // Direct use of properties returned from backend
    const displayFileName = file.name; // Use 'name' from backend
    const displayFileType = file.type; // Use 'type' from backend
    const displayFileSize = file.size; // Use 'size' from backend
    const displayUploadTime = file.uploadedAt // Use 'uploadedAt' from backend
      ? formatTimestamp(file.uploadedAt)
      : "N/A";

    return (
      <div
        key={file.fileId} // Use the backend-provided unique fileId as key
        // ... (rest of component remains the same)
      >
        {/* ... */}
        <span
          className="font-bold text-sm truncate"
          title={displayFileName}
        >
          {displayFileName}
        </span>
        {/* ... */}
        <div className="text-xs text-gray-600">
          {displayFileType} • {displayFileSize}
        </div>
        <div className="text-xs text-gray-500 mt-1">
          Uploaded at {displayUploadTime}
        </div>
        {/* ... */}
      </div>
    );
  })}

  // Lines 158-170 (handleFileUpload update to use backend's returned file object)
  // This requires the backend's /upload POST endpoint to return the new file data.
  axiosInstance
    .post("/upload", formData, { /* ... */ })
    .then((response) => {
      if (response.data.success) {
        setFiles((prevFiles) => [...prevFiles, response.data.file]); // Assuming response.data.file contains the full file object
        notify("✅ File uploaded successfully!", "success");
      } else {
        notify(response.data.message || "❌ Upload failed!", "error");
      }
    })
    // ...
  ```
  **Priority:** HIGH

**Line(s):** 115, 118, 368, 391-394
- **Issue Type:** LOGIC / MAINTAINABILITY / UX
  **Description:** Several UI elements display hardcoded static values, such as "UserName", "12:33", and generic "Recent Activity" entries. These should be dynamic, reflecting actual user data, current time/last activity, and real-time events to provide a meaningful and engaging user experience.
  **Line(s) to Fix:** 115, 118, 368, 391-394
  **Current Code:**
  ```html
  // Line 115
  <span className="font-semibold">UserName</span>
  // Line 118
  <div className="bg-black text-white px-3 py-2 text-sm font-mono">12:33</div>
  // Line 368
  <span>Last message: 12:33</span>
  // Lines 391-394
  <h3 className="font-bold mb-3">Recent Activity</h3>
  <div className="bg-white border border-black p-3">
    <div className="text-xs text-gray-600 space-y-2">
      <div>• Document uploaded</div>
      <div>• AI analysis complete</div>
      <div>• Chat session started</div>
    </div>
  </div>
  ```
  **Suggested Fix:** Use dynamic data from state or props.
  ```javascript
  // In Dashboard component (after state declarations):
  // For current time in header:
  const [currentDisplayTime, setCurrentDisplayTime] = useState(getCurrentTimestamp());
  useEffect(() => {
    const intervalId = setInterval(() => {
      setCurrentDisplayTime(getCurrentTimestamp());
    }, 60 * 1000); // Update every minute
    return () => clearInterval(intervalId); // Cleanup on unmount
  }, []);

  // In JSX:
  // Line 115: Use `userData` from state (set on line 64)
  <span className="font-semibold">{userData || "Guest User"}</span>

  // Line 118:
  <div className="bg-black text-white px-3 py-2 text-sm font-mono">{currentDisplayTime}</div>

  // Line 368:
  <span>Last message:{" "}
    {chatMessages.length > 0
      ? chatMessages[chatMessages.length - 1].timestamp
      : getCurrentTimestamp()} {/* Show current time if no messages yet */}
  </span>

  // Lines 391-394: Requires a new state variable (e.g., `recentActivities`) and logic to populate it.
  // Example (conceptual):
  // const [recentActivities, setRecentActivities] = useState([
  //   "Chat session started" // Initial activity
  // ]);
  // // Add activities on file upload success, AI response, etc.
  // // setRecentActivities(prev => [...prev, "Document uploaded"]);
  // // setRecentActivities(prev => [...prev, "AI analysis complete"]);
  // In JSX:
  // <h3 className="font-bold mb-3">Recent Activity</h3>
  // <div className="bg-white border border-black p-3">
  //   <div className="text-xs text-gray-600 space-y-2">
  //     {recentActivities.map((activity, index) => <div key={index}>• {activity}</div>)}
  //   </div>
  // </div>
  ```
  **Priority:** MEDIUM

**Line(s):** 182-194
- **Issue Type:** BUG / LOGIC / MAINTAINABILITY
  **Description:** The `removeFile` function correctly calls the backend's delete endpoint. However, the backend implementation (`server/src/controllers/upload.controller.js:deleteUploadedFiles`) does not delete the physical file from disk. This means files removed from the UI will reappear upon refresh, leading to data inconsistencies and storage bloat on the server.
  **Line(s) to Fix:** 182-194 (client-side calls are okay, but this issue highlights a critical backend gap)
  **Current Code:**
  ```javascript
  const removeFile = (fileId) => {
    axiosInstance
      .delete(`/upload/${fileId}`)
      .then((response) => {
        if (response.data.success) {
          setFiles((prev) => prev.filter((file) => file.fileId !== fileId));
          notify("✅ File deleted successfully!", "success");
        } else {
          notify(response.data.message || "❌ File deletion failed!", "error");
        }
      })
      .catch((error) => {
        console.error("File deletion error:", error);
        notify("❌ File deletion failed!", "error");
      });
  };
  ```
  **Suggested Fix:** This requires a fix on the backend (`server/src/controllers/upload.controller.js`), but for the frontend to be fully functional, it's crucial. Ensure the backend deletes the physical file from disk along with database entries and ChromaDB vectors.
  **Priority:** HIGH (Backend dependency)

**Line(s):** 214
- **Issue Type:** STYLE / UX
  **Description:** The loading spinner uses `border-b-2 border-black` which creates a quarter-circle animation. While functional, a more conventional and universally recognized spinner animation typically involves a full circle with one or more borders transparent or a different color (e.g., `border-2 border-gray-400 border-t-2 border-black`) to give a smoother, continuous rotation effect.
  **Line(s) to Fix:** 214
  **Current Code:**
  ```html
  <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-black mr-2"></div>
  ```
  **Suggested Fix:** Adjust the border styles for a more standard spinner appearance.
  ```html
  <div className="animate-spin rounded-full h-4 w-4 border-2 border-gray-400 border-t-2 border-black mr-2"></div>
  ```
  **Priority:** LOW

**Line(s):** 258
- **Issue Type:** BUG / LOGIC / UX
  **Description:** The "Download" button for uploaded files is rendered in the UI but currently has no `onClick` handler attached. This means it is purely decorative and provides no functional way for users to download the associated file. This is a core missing feature.
  **Line(s) to Fix:** 258
  **Current Code:**
  ```html
  <button
    className="p-1 hover:bg-black hover:text-white transition-colors"
    title="Download"
  >
    <Download className="h-3 w-3" />
  </button>
  ```
  **Suggested Fix:** Add an `onClick` handler that triggers the file download. This would typically involve constructing a download URL (e.g., `/api/download/${file.fileId}`) and opening it in a new tab or initiating a download via an `<a>` tag. (Requires the backend to implement a `GET /download/:fileId` endpoint).
  ```html
  <button
    onClick={() => {
      // Implement download logic here. Example:
      // window.open(`/api/v1/upload/download/${file.fileId}`, '_blank'); // Adjust path as per backend
      notify(`Downloading ${file.name}... (feature not yet fully implemented on backend)`, "info");
    }}
    className="p-1 hover:bg-black hover:text-white transition-colors"
    title="Download"
  >
    <Download className="h-3 w-3" />
  </button>
  ```
  **Priority:** HIGH

**Line(s):** 379, 382, 385
- **Issue Type:** BUG / LOGIC / UX
  **Description:** The "New Chat", "Export Chat", and "Clear History" buttons within the "Quick Actions" section are displayed but currently lack `onClick` handlers. As a result, they do not perform any actions when clicked, which will lead to a confusing and frustrating user experience.
  **Line(s) to Fix:** 379, 382, 385
  **Current Code:**
  ```html
  <button className="w-full p-2 border border-black hover:bg-black hover:text-white transition-colors text-sm">
    New Chat
  </button>
  <button className="w-full p-2 border border-black hover:bg-black hover:text-white transition-colors text-sm">
    Export Chat
  </button>
  <button className="w-full p-2 border border-black hover:bg-black hover:text-white transition-colors text-sm">
    Clear History
  </button>
  ```
  **Suggested Fix:** Implement appropriate `onClick` handlers for each button, including calls to backend if necessary.
  ```javascript
  const handleNewChat = () => {
    setChatMessages([ // Reset to initial AI message
      {
        id: uuidv4(), // Use unique ID
        type: "ai",
        content: "Hello! I've analyzed your uploaded documents. What would you like to know about them?",
        timestamp: getCurrentTimestamp(),
      },
    ]);
    setMessage(""); // Clear message input
    setFiles([]); // Optionally clear files as well for a "new session"
    notify("✅ New chat session started!", "success");
    // TODO: Consider an API call to reset backend session if relevant (e.g., clear ChromaDB context for user)
  };

  const handleExportChat = () => {
    const chatContent = chatMessages
      .map((msg) => `${msg.timestamp} [${msg.type.toUpperCase()}]: ${msg.content}`)
      .join('\n\n');
    const blob = new Blob([chatContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `chat_history_${new Date().toISOString().slice(0, 10)}.txt`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    notify("✅ Chat exported successfully!", "success");
  };

  const handleClearHistory = async () => {
    if (window.confirm("Are you sure you want to clear all chat history? This action cannot be undone.")) {
      try {
        // TODO: Add backend API call to clear history (e.g., axiosInstance.post('/users/clear-chat-history'))
        // const response = await axiosInstance.post('/users/clear-chat-history');
        // if (response.data.success) {
          setChatMessages([ // Reset to initial AI message
            {
              id: uuidv4(),
              type: "ai",
              content: "Hello! I've analyzed your uploaded documents. What would you like to know about them?",
              timestamp: getCurrentTimestamp(),
            },
          ]);
          setFiles([]); // Optionally clear files if chat history implies associated documents
          notify("✅ Chat history cleared!", "success");
        // } else {
        //   notify(response.data.message || "❌ Failed to clear chat history!", "error");
        // }
      } catch (error) {
        console.error("Error clearing chat history:", error);
        notify("❌ Failed to clear chat history!", "error");
      }
    }
  };

  // In JSX:
  <button
    onClick={handleNewChat}
    className="w-full p-2 border border-black hover:bg-black hover:text-white transition-colors text-sm"
  >
    New Chat
  </button>
  <button
    onClick={handleExportChat}
    className="w-full p-2 border border-black hover:bg-black hover:text-white transition-colors text-sm"
  >
    Export Chat
  </button>
  <button
    onClick={handleClearHistory}
    className="w-full p-2 border border-black hover:bg-black hover:text-white transition-colors text-sm"
  >
    Clear History
  </button>
  ```
  **Priority:** HIGH

**Line(s):** 205
- **Issue Type:** STYLE
  **Description:** The `title={fileName}` attribute on the `<span>` element is redundant as the filename is truncated in the display. If the filename is truncated for display, the `title` attribute should show the *full* original filename to provide the user with the complete context on hover.
  **Line(s) to Fix:** 205
  **Current Code:**
  ```html
  <span
    className="font-bold text-sm truncate"
    title={fileName}
  >
    {fileName}
  </span>
  ```
  **Suggested Fix:** If `fileName` is already truncated, pass the original full name to `title`. This requires `file.name` to be the full name, as per the previous suggested fix for `file` object consistency.
  ```html
  <span
    className="font-bold text-sm truncate"
    title={file.originalFileName || file.name} // Assuming backend provides originalFileName or client stores it
  >
    {displayFileName}
  </span>
  ```
  **Priority:** LOW

**Line(s):** 50, 99, 167
- **Issue Type:** STYLE / LOGIC
  **Description:** In `axios` error handling blocks, `console.error` is immediately followed by a `notify` call. While both serve different purposes (developer debugging vs. user feedback), their direct sequential use can be slightly redundant for simple UI notifications.
  **Line(s) to Fix:** 50, 99, 167
  **Current Code:**
  ```javascript
  console.error("Error fetching files:", error);
  notify("❌ Failed to fetch files!", "error");
  ```
  **Suggested Fix:** Keep as is if direct console output during development is desired. In a production setting, `console.error` should ideally be handled by a centralized logging system or conditionally enabled.
  ```javascript
  // No change needed, or add conditional logging:
  // if (process.env.NODE_ENV === 'development') {
  //   console.error("Error fetching files:", error);
  // }
  // notify("❌ Failed to fetch files!", "error");
  ```
  **Priority:** LOW

**File:** `client/src/screens/Login.jsx`
**Line(s):** 31
- **Issue Type:** LOGIC / SECURITY
  **Description:** The `removeToken()` call in the `catch` block (line 31) when `response.data.success` is false is problematic. If login fails due to incorrect credentials (an expected failure), `removeToken()` would clear a potentially valid token if the user was already logged in (e.g., token expired, so they tried to re-login, but entered wrong credentials this time). The token should only be removed if the login attempt explicitly results in a server-side invalidation of the *current* token, or on explicit logout.
  **Line(s) to Fix:** 31
  **Current Code:**
  ```javascript
          } else {\r\n            setIsLoading(false);\r\n            notify(response.data.error || "Login failed!", "error");\r\n            removeToken(); // <-- Problematic\r\n          }\r\n  ```
  **Suggested Fix:** Remove `removeToken()` from this `else` block.
  ```javascript
          } else {\r\n            setIsLoading(false);\r\n            notify(response.data.error || "Login failed! Invalid credentials.", "error");\r\n            // removeToken(); // DO NOT remove token here on failed login attempt\r\n          }\r\n  ```
  **Priority:** MEDIUM

**Line(s):** 33
- **Issue Type:** STYLE / MAINTAINABILITY
  **Description:** The `setIsLoading(false)` is called twice: once inside the `if/else` block (lines 28, 30) and again in the `finally` block (line 33). This is redundant. The `finally` block is sufficient for ensuring `isLoading` is reset regardless of success or error.
  **Line(s) to Fix:** 33 (and previous `setIsLoading(false)` calls)
  **Current Code:**
  ```javascript
      } catch (error) {\r\n        setIsLoading(false);\r\n        // ...\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n  ```
  **Suggested Fix:** Remove the `setIsLoading(false)` calls from inside the `try` and `catch` blocks, keeping only the one in `finally`.
  ```javascript
      setIsLoading(true);\r\n      try {\r\n        const response = await axiosInstance.post("/auth/login", formData);\r\n        if (response.data.success) {\r\n          const token = response.data.data?.accessToken;\r\n          setToken(token);\r\n          notify("✅ Login successful!", "success");\r\n          navigate("/dashboard");\r\n        } else {\r\n          notify(response.data.error || "Login failed!", "error");\r\n        }\r\n      } catch (error) {\r\n        console.error("Login error:", error);\r\n        const errorMsg =\r\n          error.response?.data?.error || "❌ Something went wrong!";\r\n        notify(errorMsg, "error");\r\n      } finally {\r\n        setIsLoading(false); // Only set it once here\r\n      }\r\n  ```
  **Priority:** LOW

**Line(s):** 76-79, 81-84, 114-117
- **Issue Type:** MAINTAINABILITY / UX
  **Description:** The `href` values (`#`, `#register`, `#forgot-password`) are placeholders. For proper navigation in a React application using `react-router-dom`, these should either be actual route paths using the `<Link>` component or an `onClick` handler should be implemented to navigate programmatically using the `navigate` hook. Using `href="#"` can cause unintended scroll-to-top behavior.
  **Line(s) to Fix:** 76-79, 81-84, 114-117
  **Current Code:**
  ```html
  // Line 76
  <a href="#" ...>Back to home</a>
  // Line 81
  <a href="#register" ...>Sign up for free</a>
  // Line 114
  <a href="#forgot-password" ...>Forgot password?</a>
  ```
  **Suggested Fix:** Use `Link` components for internal navigation.
  ```javascript
  // Import Link from 'react-router-dom': import { Link } from "react-router-dom";

  // For Back to home:
  <Link to="/" className="flex items-center text-gray-600 hover:text-black transition-colors">
    <ArrowLeft className="h-4 w-4 mr-2" />
    Back to home
  </Link>

  // For Sign up for free:
  <Link to="/signup" className="font-semibold hover:underline">
    Sign up for free
  </Link>

  // For Forgot password? (if page exists):
  <Link to="/forgot-password" className="text-sm font-semibold hover:underline">
    Forgot password?
  </Link>
  // If no actual page, consider removing the link or adding a notification on click.
  ```
  **Priority:** MEDIUM

**File:** `client/src/screens/SignUp.jsx`
**Line(s)::** 149-151
- **Issue Type:** LOGIC / UX
  **Description:** The password strength text logic `if (passwordStrength <= 1) return "Weak";` might be too lenient. If `passwordStrength` is 0 (no criteria met), it correctly won't display, but if `passwordStrength` is 1 (e.g., only length criterion met), it shows "Weak". It could be more granular or have a "Too Short" or "Very Weak" category for 0-1 criteria met.
  **Line(s) to Fix:** 149-151
  **Current Code:**
  ```javascript
    const getStrengthText = () => {\r\n      if (passwordStrength <= 1) return "Weak";\r\n      if (passwordStrength <= 3) return "Medium";\r\n      return "Strong";\r\n    };\r\n  ```
  **Suggested Fix:** Adjust the strength mapping to be more descriptive.
  ```javascript
    const getStrengthText = () => {\r\n      if (passwordStrength === 0) return "Too Short / None";\r\n      if (passwordStrength <= 2) return "Weak";\r\n      if (passwordStrength <= 4) return "Medium";\r\n      return "Strong";\r\n    };\r\n  ```
  **Priority:** LOW

**Line(s):** 70-75
- **Issue Type:** BUG / LOGIC / ERROR_HANDLING
  **Description:** The `handleSubmit` function performs an `axiosInstance.post` call for signup without a `try...catch` block around the asynchronous operation itself. While there's a `.catch` attached to the Promise, it won't handle synchronous errors thrown before the Promise is created or unhandled promise rejections that might escape the chain if not properly structured (though less common with `axios`). It's safer to use `async/await` with `try...catch`. Also, `removeToken()` is called even on a failed signup (line 74), which is incorrect logic.
  **Line(s) to Fix:** 70-75
  **Current Code:**
  ```javascript
    const handleSubmit = (e) => {\r\n      e.preventDefault();\r\n      //handling form submission\r\n      axiosInstance\r\n        .post("/auth/signup", {\r\n          name: `${formData.firstName} ${formData.lastName}`,\r\n          email: formData.email,\r\n          password: formData.password,\r\n        })\r\n        .then(({ data }) => {\r\n          if (data.success) {\r\n            const token = data.data?.accessToken;\r\n            setToken(token);\r\n            notify("✅ Signup successful!", "success");\r\n            navigate("/dashboard");\r\n          } else {\r\n            notify(data.message || "Signup failed!", "error");\r\n            removeToken(); // <-- Incorrect: token should not be removed on failed signup\r\n          }\r\n        })\r\n        .catch((error) => {\r\n          console.error("Signup error:", error);\r\n\r\n          // Agar backend ka error message ho to dikha do\r\n          const errorMsg =\r\n            error.response?.data?.error || "❌ Something went wrong!";\r\n          notify(errorMsg, "error");\r\n        });\r\n    };\r\n  ```
  **Suggested Fix:** Use `async/await` with a `try...catch` block for robust error handling. Remove `removeToken()` on failed signup.
  ```javascript
  const handleSubmit = async (e) => { // Mark as async
    e.preventDefault();
    try {
      const response = await axiosInstance.post("/auth/signup", {
        name: `${formData.firstName} ${formData.lastName}`,
        email: formData.email,
        password: formData.password,
      });

      if (response.data.success) {
        const token = response.data.data?.accessToken;
        setToken(token);
        notify("✅ Signup successful!", "success");
        navigate("/dashboard");
      } else {
        notify(response.data.message || "Signup failed!", "error");
        // removeToken(); // Remove this line
      }
    } catch (error) {
      console.error("Signup error:", error);
      const errorMsg =
        error.response?.data?.error || "❌ Something went wrong!";
      notify(errorMsg, "error");
    }
  };
  ```
  **Priority:** MEDIUM

**Line(s):** 105-108, 110-113
- **Issue Type:** MAINTAINABILITY / UX
  **Description:** Similar to `Login.jsx`, the `href` values (`#`, `#login`, `#`) are placeholders. These should either be actual route paths using the `<Link>` component or `onClick` handlers should be implemented for programmatic navigation.
  **Line(s) to Fix:** 105-108, 110-113
  **Current Code:**
  ```html
  // Line 105
  <a href="#" className="flex items-center text-gray-600 hover:text-black transition-colors">Back to home</a>
  // Line 108
  <a href="#login" className="font-semibold hover:underline">Sign in here</a>
  // Line 110-113
  <a href="#" className="font-semibold hover:underline">Terms of Service</a>
  // ...
  <a href="#" className="font-semibold hover:underline">Privacy Policy</a>
  ```
  **Suggested Fix:** Use `Link` components for internal navigation.
  ```javascript
  // Import Link from 'react-router-dom': import { Link } from "react-router-dom";

  // For Back to home:
  <Link to="/" className="flex items-center text-gray-600 hover:text-black transition-colors">
    <ArrowLeft className="h-4 w-4 mr-2" />
    Back to home
  </Link>

  // For Sign in here:
  <Link to="/login" className="font-semibold hover:underline">
    Sign in here
  </Link>

  // For Terms of Service and Privacy Policy (if pages exist):
  <a href="/terms" className="font-semibold hover:underline">
    Terms of Service
  </a>
  // ...
  <a href="/privacy" className="font-semibold hover:underline">
    Privacy Policy
  </a>
  // If no actual pages, consider removing the links or adding a notification on click.
  ```
  **Priority:** MEDIUM

**File:** `server/config/contants.js`
**Line(s):** 1, 7
- **Issue Type:** SECURITY / MAINTAINABILITY / STYLE
  **Description:**
    1.  **Typo:** The filename `contants.js` contains a typo and should be `constants.js` for proper spelling and readability.
    2.  **Debug Log:** The `//console.log(JWT_SECRET);` is commented-out debug code. Even if commented, it's good practice to remove it from production code to keep the codebase clean.
  **Line(s) to Fix:** 1, 7 (and the filename)
  **Current Code:**
  ```javascript
  import { config } from "dotenv";
  config({ path: "./.env.local" });

  export const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
  export const GEMINI_EMBEDDINGS_MODEL = "gemini-embedding-001";
  export const CHROMADB_API_KEY = process.env.CHROMADB_API_KEY;
  export const JWT_SECRET = process.env.MY_JWT_SECRET;
  //console.log(JWT_SECRET);
  ```
  **Suggested Fix:**
  1.  Rename `contants.js` to `constants.js`.
  2.  Remove the `console.log` statement.
  ```javascript
  import { config } from "dotenv";
  config({ path: "./.env.local" });

  export const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
  export const GEMINI_EMBEDDINGS_MODEL = "gemini-embedding-001";
  export const CHROMADB_API_KEY = process.env.CHROMADB_API_KEY;
  export const JWT_SECRET = process.env.MY_JWT_SECRET;
  // (Remove console.log line)
  ```
  **Priority:** MEDIUM

**File:** `server/server.js`
**Line(s):** 6
- **Issue Type:** MAINTAINABILITY
  **Description:** The `client` object is imported from `./src/database/chroma.db.js` but is not used directly within `server.js`. Removing unused imports improves code clarity.
  **Line(s) to Fix:** 6
  **Current Code:** `import { client } from "./src/database/chroma.db.js";`
  **Suggested Fix:** Remove the unused import.
  ```javascript
  // import { client } from "./src/database/chroma.db.js"; // This import is unused in server.js
  ```
  **Priority:** LOW

**Line(s):** 10-12
- **Issue Type:** LOGIC / MAINTAINABILITY
  **Description:** The server's `listen` operation lacks explicit error handling for scenarios where the server fails to start (e.g., port already in use, invalid port). Without an `.on('error', ...)` handler, the Node.js process might crash abruptly instead of logging the error and attempting a graceful exit. Additionally, there is no graceful shutdown mechanism for the server, which is crucial for production environments to ensure resources (like database connections) are properly closed upon termination signals (`SIGTERM`, `SIGINT`).
  **Line(s) to Fix:** 10-12 (and after)
  **Current Code:**
  ```javascript
  server.listen(port, () => {
    logger.info(`Server is running on port ${port}`);
  });
  ```
  **Suggested Fix:** Add an error event listener and implement graceful shutdown handlers.
  ```javascript
  server.listen(port, () => {
    logger.info(`Server is running on port ${port}`);
  }).on('error', (err) => { // Add error event listener
    logger.error(`Server failed to start on port ${port}: ${err.message}`);
    process.exit(1); // Exit with a non-zero code to indicate an error
  });

  // Add graceful shutdown handling
  const gracefulShutdown = () => {
    logger.info('Received shutdown signal, shutting down gracefully...');
    server.close(() => {
      logger.info('HTTP server closed.');
      // If database connections (SQLite, ChromaDB client) need explicit closing,
      // add that logic here before exiting.
      // E.g., if (db && typeof db.close === 'function') db.close();
      process.exit(0);
    });

    // Force close after a timeout if server doesn't close gracefully
    setTimeout(() => {
      logger.error('Could not close connections in time, forcefully shutting down');
      process.exit(1);
    }, 10000); // 10 seconds timeout
  };

  process.on('SIGTERM', gracefulShutdown); // Handle termination signal
  process.on('SIGINT', gracefulShutdown);  // Handle interrupt signal (Ctrl+C)
  ```
  **Priority:** HIGH

**File:** `server/src/app.js`
**Line(s):** 11
- **Issue Type:** BUG / MAINTAINABILITY
  **Description:** The `cookieParser` module is imported but never actually used as a middleware (`app.use(cookieParser());`). Without this, any cookie parsing functionality will not be active, which is likely required for handling refresh tokens (as used in `auth.controller.js`).
  **Line(s) to Fix:** 11
  **Current Code:** `import cookieParser from "cookie-parser";`
  **Suggested Fix:** Add `app.use(cookieParser());` before routes that require cookie parsing.
  ```javascript
  import express from "express";
  import cors from "cors";
  import morgan from "morgan";
  import helmet from "helmet";
  import compression from "compression";
  import { rateLimit } from "express-rate-limit";
  import authRoute from "./routes/auth.route.js";
  import uploadRoute from "./routes/upload.route.js";
  import chatRoute from "./routes/chat.route.js";
  import userRoute from "./routes/user.route.js";
  import cookieParser from "cookie-parser"; // Keep this import
  import { verifyJwtToken } from "./middlewares/auth.middleware.js";

  export const app = express();

  // ... existing middleware ...

  app.use(express.json());
  app.use(express.urlencoded({ extended: true }));
  app.use(cookieParser()); // Add this line to enable cookie parsing

  // ... api endpoints ...
  ```
  **Priority:** MEDIUM

**File:** `server/src/controllers/auth.controller.js`
**Line(s)::** 4-5
- **Issue Type:** STYLE / MAINTAINABILITY
  **Description:** The imports `success` from "zod" and `da` from "zod/v4/locales" are unused in this file. Unused imports clutter the code and can lead to confusion.
  **Line(s) to Fix:** 4-5
  **Current Code:**
  ```javascript
  import cookieParser from "cookie-parser";
  import { success } from "zod"; // Unused
  import { da } from "zod/v4/locales"; // Unused
  ```
  **Suggested Fix:** Remove the unused imports.
  ```javascript
  // Remove these lines entirely.
  ```
  **Priority:** LOW

**Line(s):** 8, 20, 38
- **Issue Type:** STYLE / DEBUG / SECURITY
  **Description:** There are `console.log` statements (lines 8, 38) and a commented-out `console.log` (line 20) used for debugging. Debugging logs should be removed from production code as they can expose sensitive information (like `req.body` containing passwords), clutter server logs, and have a minor performance impact. Commented-out code also clutters the codebase.
  **Line(s) to Fix:** 8, 20, 38
  **Current Code:**
  ```javascript
  // Line 8: console.log(req.body);
  // Line 20: //console.log(existingUser);
  // Line 38: console.log(newUser);
  ```
  **Suggested Fix:** Remove all these lines. For internal logging, use the `logger` utility if necessary.
  ```javascript
  // (Remove these lines)
  ```
  **Priority:** LOW

**Line(s):** 17, 71
- **Issue Type:** BUG / LOGIC
  **Description:** The `runQuery` function (from `sqlLite.db.js`) is synchronous, and when used with `SELECT ... LIMIT 1`, it returns either a single object or `undefined` (if no row is found) via `stmt.get()`.
    1.  **Line 17:** `const existingUser = runQuery(...)` is then followed by `existingUser.length > 0` on line 22. If no user is found, `existingUser` will be `undefined`, and attempting to access `.length` on `undefined` will throw a `TypeError`, crashing the application.
    2.  **Line 71:** Similar issue for login, `const user = runQuery(...)` is followed by `user.length === 0` on line 72, which will also `TypeError` if no user is found.
  **Line(s) to Fix:** 17, 71
  **Current Code:**
  ```javascript
  // Line 17:
  const existingUser = runQuery(`SELECT * FROM userData WHERE email = ?`, [email,]);
  // Line 71:
  const user = runQuery(`SELECT * FROM userData WHERE email = ?`, [email]);
  ```
  **Suggested Fix:** Replace `.length` checks with a direct check for the existence of the returned object.
  ```javascript
  // Line 17:
  const existingUser = runQuery(`SELECT * FROM userData WHERE email = ?`, [email,]);
  if (existingUser) { // Correctly checks if an object was returned
    return res
      .status(409)
      .json({ success: false, error: "User already exists" });
  }

  // Line 71:
  const user = runQuery(`SELECT * FROM userData WHERE email = ?`, [email]);
  if (!user) { // Correctly checks if an object was returned
    return res.status(404).json({ success: false, error: "User not found" });
  }
  ```
  **Priority:** HIGH

**Line(s):** 40-42, 75-77
- **Issue Type:** BUG / LOGIC / MAINTAINABILITY
  **Description:** The `createJwtToken` function (in `jwtMaker.js`) expects a single `payload` object as its first argument (as per its internal logic defining `accessTokenPayload` and `refreshTokenPayload` with `email` and `userId` keys). However, it is being called with `userEmail` and `userId` as two separate arguments (lines 40, 75). This is a mismatch in the function signature and expected arguments, leading to `accessTokenPayload` and `refreshTokenPayload` being incorrectly formed (e.g., `payload.email` will be `undefined` because `payload` will be the `email` string itself, not an object). This will result in invalid JWT tokens.
  **Line(s) to Fix:** 40-42, 75-77
  **Current Code:**
  ```javascript
  // Line 40-42:
  const { accessToken, refreshToken } = createJwtToken(
    email,
    newUser.lastInsertRowid
  );
  // Line 75-77:
  const { accessToken, refreshToken } = createJwtToken(
    user[0].email,
    user[0].userId
  );
  ```
  **Suggested Fix:** Pass the payload as a single object as expected by `createJwtToken`.
  ```javascript
  // In handleUserSignUp (Line 40-42):
  const { accessToken, refreshToken } = createJwtToken({
    email: email,
    userId: newUser.lastInsertRowid, // Assuming newUser.lastInsertRowid is correct
  });

  // In handleUserLogin (Line 75-77):
  const { accessToken, refreshToken } = createJwtToken({
    email: user.email, // Use user.email directly after `if (!user)` check
    userId: user.userId, // Use user.userId directly
  });
  ```
  **Priority:** HIGH

**Line(s)::** 46, 90
- **Issue Type:** MAINTAINABILITY / DEVELOPMENT_EXPERIENCE
  **Description:** The cookie configuration sets `secure: true` for the refresh token cookie. While `secure: true` is crucial for production to ensure cookies are only sent over HTTPS, this setting will prevent the cookie from being set if the application is running locally over HTTP (e.g., `localhost`). This can lead to unexpected behavior and debugging difficulties during development.
  **Line(s) to Fix:** 46, 90
  **Current Code:**
  ```javascript
  // Line 46 & 90
  secure: true, // Only send cookie over HTTPS
  ```
  **Suggested Fix:** Conditionally set `secure` based on the environment, typically `process.env.NODE_ENV === 'production'`.
  ```javascript
  // Line 46 & 90
  secure: process.env.NODE_ENV === 'production', // Set to true only in production
  ```
  **Priority:** MEDIUM

**Line(s):** 16-46, 56-78 (Entire function bodies)
- **Issue Type:** BUG / ERROR_HANDLING
  **Description:** The `handleUserSignUp` and `handleUserLogin` functions, despite being `async`, do not wrap all their asynchronous operations (like `bcrypt.hash`, `bcrypt.compare`, and `createJwtToken`) in `try...catch` blocks. If any of these operations fail, the Node.js process will crash due to an unhandled promise rejection or uncaught exception. This leads to server instability and a poor user experience, as clients receive no proper error response.
  **Line(s) to Fix:** 16-46 (for `handleUserSignUp`), 56-78 (for `handleUserLogin`)
  **Current Code:** (Example showing lack of `try...catch` around async calls within the main function `try` block, or outside it)
  ```javascript
  // In handleUserSignUp:
  // ... check existing user (already problematic, see above)
  const hashedPassword = await bcrypt.hash(password, 10); // Not in its own try-catch
  const newUser = await runQuery(...); // Not in its own try-catch (if runQuery could throw)
  const { accessToken, refreshToken } = createJwtToken(...); // Not in its own try-catch

  // In handleUserLogin:
  // ... check user existence (already problematic, see above)
  const isPasswordValid = await bcrypt.compare(password, user[0].password); // Not in its own try-catch
  const { accessToken, refreshToken } = createJwtToken(...); // Not in its own try-catch
  ```
  **Suggested Fix:** Wrap the main logic of each handler in a `try...catch` block to handle all potential errors, including those from `bcrypt` and `createJwtToken`. Also, ensure `runQuery` is handled as per the previous suggested fix.
  ```javascript
  // (Full function bodies, incorporating previous fixes for missing await and JWT payload)
  import bcrypt from "bcrypt";
  import { createJwtToken } from "../utils/jwtMaker.js";
  import { runQuery } from "../database/sqlLite.db.js";
  // Remove unused zod imports

  export const handleUserSignUp = async (req, res) => {
    const { name, email, password } = req.body;
    // Remove: console.log(req.body);
    if (!name || !email || !password) {
      return res
        .status(400)
        .json({ success: false, error: "All fields are required" });
    }

    try {
      // Check if user already exists
      const existingUser = runQuery(`SELECT * FROM userData WHERE email = ?`, [
        email,
      ]);
      // Remove: console.log(existingUser);
      if (existingUser) { // Corrected check for synchronous query result
        return res
          .status(409)
          .json({ success: false, error: "User already exists" });
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(password, 10);

      // Create new user
      const newUser = runQuery( // Assuming this returns {lastInsertRowid} synchronously
        `
        INSERT INTO userData (name, email, password)
        VALUES (?, ?, ?)
      `,
        [name, email, hashedPassword]
      );
      // Remove: console.log(newUser);

      // Generate JWT
      const { accessToken, refreshToken } = createJwtToken({ email, userId: newUser.lastInsertRowid });

      res.cookie("refreshToken", refreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production', // Conditional secure flag
        sameSite: "strict",
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
      });

      return res
        .status(201)
        .json({ success: true, data: { accessToken }, message: "SignUp successful" });
    } catch (error) {
      console.error("Error during user signup:", error); // Use console.error
      return res.status(500).json({ success: false, error: "Internal server error during signup" });
    }
  };

  export const handleUserLogin = async (req, res) => {
    const { email, password } = req.body;
    if (!email || !password) {
      return res
        .status(400)
        .json({ success: false, error: "Please provide email and password" });
    }

    try {
      // Check if user exists
      const user = runQuery(`SELECT * FROM userData WHERE email = ?`, [email]); // Synchronous query
      if (!user) { // Corrected check for synchronous query result
        return res.status(404).json({ success: false, error: "User not found" });
      }

      // Check password
      const isPasswordValid = await bcrypt.compare(password, user.password); // user.password is now directly accessible
      if (!isPasswordValid) {
        return res
          .status(401)
          .json({ success: false, error: "Invalid email or password" });
      }

      // Generate JWT
      const { accessToken, refreshToken } = createJwtToken({ email: user.email, userId: user.userId });

      res.cookie("refreshToken", refreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production', // Conditional secure flag
        sameSite: "strict",
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
      });

      return res
        .status(200)
        .json({ success: true, data: { accessToken }, message: "Login successful" });
    } catch (error) {
      console.error("Error during user login:", error); // Use console.error
      return res.status(500).json({ success: false, error: "Internal server error during login" });
    }
  };
  ```
  **Priority:** HIGH

**File:** `server/src/controllers/chat.controller.js`
**Line(s)::** 6
- **Issue Type:** MAINTAINABILITY
  **Description:** The `db` import from `../database/sqlLite.db.js` is declared but never used within this file. Unused imports clutter the code.
  **Line(s) to Fix:** 6
  **Current Code:** `import { db, runQuery } from "../database/sqlLite.db.js";`
  **Suggested Fix:** Remove the unused `db` import.
  ```javascript
  import { runQuery } from "../database/sqlLite.db.js";
  ```
  **Priority:** LOW

**Line(s):** 15, 32, 35, 41, 44
- **Issue Type:** STYLE / DEBUG
  **Description:** There are several `console.log` statements used for debugging purposes (lines 15, 32, 35, 41, 44). These should be removed from production code as they can leak sensitive information, reduce performance, and clutter server logs. The `logger.info` calls are more appropriate for production logging.
  **Line(s) to Fix:** 15, 32, 35, 41, 44
  **Current Code:**
  ```javascript
  // Line 15: logger.info(userMsg); // This is already logger, but could be more descriptive
  // Line 32: console.log("chatid", chatId);
  // Line 35: console.log("embedding length", embeddings.length);
  // Line 41: console.log("vectorIds", vectorIds);
  // Line 44: console.log(error);
  ```
  **Suggested Fix:** Replace `console.log` with `logger` calls or remove debug statements.
  ```javascript
  logger.info(`User message: "${userMsg}"`); // More descriptive
  logger.debug(`Chat ID: ${chatId}`); // Use debug level for detailed info
  logger.debug(`Embedding length: ${embeddings.length}`); // Use debug level
  logger.debug(`Vector IDs: ${vectorIds}`); // Use debug level
  logger.error("Error in chatWithPdf:", error); // Log full error object
  ```
  **Priority:** LOW

**Line(s):** 29
- **Issue Type:** LOGIC / MAINTAINABILITY
  **Description:** The comment `// Assuming all files belong to the same chat` highlights a critical assumption about the data model. If a user can upload multiple files that might logically belong to different `chatId`s, this implementation will incorrectly use only the `chatId` of the first file found. This could lead to the LLM searching irrelevant documents. The business logic for determining the correct `chatId` for a given user message needs to be explicitly defined. If a user truly has only *one* `chatId` across all their files, this should be a strong invariant enforced by the data model.
  **Line(s) to Fix:** 29
  **Current Code:** `const chatId = files[0].chatId; // Assuming all files belong to the same chat`
  **Suggested Fix:** Clarify the assumption or add a TODO for future refinement if multiple chat contexts are intended.
  ```javascript
  const chatId = files[0].chatId; // IMPORTANT: Current design assumes all files uploaded by a user are associated with a single, unified chat context. This might need review if multiple chat sessions per user are introduced.
  ```
  **Priority:** MEDIUM

**Line(s):** 64
- **Issue Type:** LOGIC / ERROR_HANDLING
  **Description:** Throwing an `ApiError` directly from a controller's `catch` block (i.e., `throw new ApiError(...)`) implies that an Express error-handling middleware is explicitly configured to catch this specific error type and send an HTTP response. If such a middleware is not guaranteed to be in place or correctly configured for `ApiError`, this `throw` will result in an unhandled promise rejection, potentially crashing the Node.js process. Controllers should generally aim to send a response directly (`res.status().json()`) or use `next(error)` to explicitly pass the error to the Express error-handling chain.
  **Line(s) to Fix:** 64
  **Current Code:** `throw new ApiError("Failed to process chat request", 500);`
  **Suggested Fix:** Pass the error to the `next` middleware, assuming a global error handling middleware is present (which is good practice for Express apps).
  ```javascript
  logger.error("Error in chatWithPdf:", error.message); // Already present, good.
  return next(new ApiError("Failed to process chat request", 500)); // Pass to Express error handler
  ```
  **Priority:** MEDIUM

**Line(s):** 67
- **Issue Type:** STYLE / MAINTAINABILITY
  **Description:** This line contains commented-out code (`// export const handleUserChats = (req,res)={}`). Commented-out code adds unnecessary clutter and can confuse future developers.
  **Line(s) to Fix:** 67
  **Current Code:** `// export const handleUserChats = (req,res)={}`
  **Suggested Fix:** Remove the line.
  ```javascript
  // (Remove this line)
  ```
  **Priority:** LOW

**File:** `server/src/controllers/upload.controller.js`
**Line(s)::** 7
- **Issue Type:** STYLE / MAINTAINABILITY
  **Description:** The `db` import from `../database/sqlLite.db.js` is declared but never used within this file. Unused imports clutter the code.
  **Line(s) to Fix:** 7
  **Current Code:** `import { db, runQuery } from "../database/sqlLite.db.js";`
  **Suggested Fix:** Remove the unused `db` import.
  ```javascript
  import { runQuery } from "../database/sqlLite.db.js";
  ```
  **Priority:** LOW

**Line(s):** 11-13
- **Issue Type:** STYLE / DEBUG
  **Description:** The `console.log("User found:", user);` statement on line 15 is a debug log. It should be removed from production code. The `runQuery` call on line 11 is synchronous (as determined from `sqlLite.db.js`), so `await` is not needed there, and the `if (!user)` check on line 18 is correct for handling `undefined` when no user is found. The main issue is the debug log.
  **Line(s) to Fix:** 15
  **Current Code:**
  ```javascript
  const user = runQuery("SELECT userId FROM userData WHERE email = ? LIMIT 1", [\r\n    req.user.email,\r\n  ]);\r\n  console.log("User found:", user);\r\n  try {\r\n    logger.info("Uploaded file:", req.file);\r\n    if (!user) {\r\n      throw new ApiError(404, "User not found", [req.user.email]);\r\n    }\r\n  ```
  **Suggested Fix:** Remove `console.log` and replace with `logger.info` for consistency.
  ```javascript
  const user = runQuery("SELECT userId FROM userData WHERE email = ? LIMIT 1", [\r\n    req.user.email,\r\n  ]);\r\n  logger.info("User found:", user ? user.email : "Not found"); // Use logger, log email if found\r\n  try {\r\n    logger.info("Uploaded file:", req.file);\r\n    if (!user) {\r\n      throw new ApiError(404, "User not found", [req.user.email]);\r\n    }\r\n  ```
  **Priority:** LOW

**Line(s):** 37, 43-45
- **Issue Type:** STYLE / DEBUG
  **Description:** There are `console.log` statements (line 37) and commented-out `console.log`s (lines 43-45) used for debugging. These should be removed from production code.
  **Line(s) to Fix:** 37, 43-45
  **Current Code:**
  ```javascript
  console.log("🧩 Vector inserted with ID:", vectorResult.id);\r\n\r\n  const chatId = uuidv4();\r\n  await runQuery(\r\n    `\r\nINSERT INTO files (userId, filePath, vectorId, chatId)\r\nVALUES (?, ?, ?, ?)\r\n`,\r\n    [user.userId, req.file.path, vectorResult.id, chatId]\r\n  );\r\n\r\n  // console.log("✅ File inserted with ID:", fileInsert.lastInsertRowid);\r\n  ```
  **Suggested Fix:** Remove or replace with `logger.debug`.
  ```javascript
  logger.debug("🧩 Vector inserted with ID:", vectorResult.id); // Use logger.debug

  const chatId = uuidv4();
  await runQuery(
    `
INSERT INTO files (userId, filePath, vectorId, chatId)
VALUES (?, ?, ?, ?)
`,
    [user.userId, req.file.path, vectorResult.id, chatId]
  );

  // Remove commented-out line: // console.log("✅ File inserted with ID:", fileInsert.lastInsertRowid);
  ```
  **Priority:** LOW

**Line(s):** 40, 42, 50-54, 62-67
- **Issue Type:** BUG / LOGIC / MAINTAINABILITY / DATA_CONSISTENCY
  **Description:** This section has several critical issues related to file persistence and data modeling:
    1.  **Temporary `filePath`:** The `filePath` (`req.file.path`) stored in the `files` table (line 42, 52) is Multer's temporary path. This file will be deleted after the request, making it inaccessible for future operations like downloading or re-analysis. Files intended for persistence must be moved to a permanent storage location.
    2.  **`chatId` per page:** A new `chatId` is generated using `uuidv4()` for *each page's vector* (line 40) and inserted into the `files` table. If `chatId` is meant to represent a chat session linked to a *document*, it should be one `chatId` per document, not one per page. This can lead to multiple `chatId`s for a single document.
    3.  **No single `fileId` for document:** The server does not generate and track a single unique ID for the *overall PDF file*. Instead, it focuses on `vectorId`s. The client needs a `fileId` to uniquely identify the entire PDF for actions like download or delete.
    4.  **Inefficient `files` table schema:** The `files` table (`fileId`, `userId`, `filePath`, `vectorId`, `chatId`) seems to mix per-document and per-vector data. A separate `documents` table for document-level metadata and a `vectors` table linking vectors to documents would be more robust.
    5.  **Insufficient Response to Client:** The `handlePdfUpload` response (lines 62-67) does not return sufficient information (like the actual `fileId`, `fileName`, `fileSize`, `fileType`, `uploadedAt`) to the client for it to correctly display and manage the newly uploaded file without a subsequent `GET /upload` call.
  **Line(s) to Fix:** 40, 42, 50-54, 62-67 (and related file schema)
  **Current Code:**
  ```javascript
  // Line 40
  const chatId = uuidv4();
  // Line 42 (part of SQL)
  [user.userId, req.file.path, vectorResult.id, chatId]
  // Lines 50-54 (SQL insert)
  await runQuery(
    `
    INSERT INTO files (userId, filePath, vectorId, chatId)
    VALUES (?, ?, ?, ?)
  `,
    [user.userId, req.file.path, vectorResult.id, chatId]
  );
  // Lines 62-67 (Response)
  return res.json({
    success: true,
    count: addResults.length,
    message: "PDF uploaded and processed successfully",
  });
  ```
  **Suggested Fix:** This requires a significant refactor to ensure proper file persistence, ID management, and data consistency.
  ```javascript
  // Add imports: import fs from 'fs/promises'; import path from 'path';
  // Define a permanent upload directory (e.g., in a config file)
  const UPLOAD_DIR = './uploads';

  export const handlePdfUpload = async (req, res, next) => { // Add 'next' to parameters
    const user = runQuery("SELECT userId FROM userData WHERE email = ? LIMIT 1", [\
      req.user.email,\
    ]);

    if (!user) {
      // Pass to error handler
      return next(new ApiError(404, "User not found", [req.user.email]));
    }

    let permanentFilePath; // Declare to ensure cleanup in catch

    try {
      logger.info("Uploaded file:", req.file);

      // 1. Generate a single UUID for the entire document and a consistent chat session ID
      const documentId = uuidv4();
      const chatSessionId = uuidv4(); // One chat ID per document
      const originalFileName = req.file.originalname;
      const fileExtension = path.extname(originalFileName);
      const permanentFileName = `${documentId}${fileExtension}`;
      permanentFilePath = path.join(UPLOAD_DIR, permanentFileName);

      // Ensure upload directory exists
      await fs.mkdir(UPLOAD_DIR, { recursive: true });

      // 2. Move the temporary file to a permanent location
      await fs.rename(req.file.path, permanentFilePath);
      logger.info(`File moved to permanent storage: ${permanentFilePath}`);

      // 3. Store document metadata in database (assuming 'files' table is now 'documents' or adjusted)
      // NOTE: This assumes 'files' table schema is updated to support these columns:
      // CREATE TABLE IF NOT EXISTS files (
      //   fileId             TEXT PRIMARY KEY, // Use TEXT for UUID
      //   userId             INTEGER NOT NULL,
      //   filePath           TEXT NOT NULL,    // Permanent path
      //   originalFileName   TEXT NOT NULL,
      //   fileSize           INTEGER NOT NULL,
      //   fileType           TEXT NOT NULL,
      //   uploadedAt         DATETIME DEFAULT CURRENT_TIMESTAMP,
      //   chatId             TEXT,             // Unified chat ID for the document
      //   FOREIGN KEY (userId) REFERENCES userData(userId) ON DELETE CASCADE
      // );
      //
      // And a separate table for vectors if needed, e.g.:
      // CREATE TABLE IF NOT EXISTS documentVectors (
      //   vectorId TEXT PRIMARY KEY,
      //   documentId TEXT NOT NULL,
      //   pageNumber INTEGER,
      //   FOREIGN KEY (documentId) REFERENCES files(fileId) ON DELETE CASCADE
      // );
      await runQuery(
        `INSERT INTO files (fileId, userId, filePath, originalFileName, fileSize, fileType, uploadedAt, chatId)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
        [documentId, user.userId, permanentFilePath, originalFileName, req.file.size, req.file.mimetype, Date.now(), chatSessionId]
      );
      logger.info(`Document metadata inserted for documentId: ${documentId}`);

      // 4. Chunk the PDF into pages using the permanent path
      const pages = await chunkPdf(permanentFilePath);

      // 5. Process each page, add vectors, and link to the main document ID
      const vectorInsertPromises = pages.map(async (page, index) => {
        const embedding = await getEmbeddings(page.pageContent);
        const vectorId = uuidv4(); // Unique ID for each vector chunk

        const vectorResult = await addVector({
          id: vectorId,
          embedding,
          userId: user.userId, // Pass userId for filtering in Chroma search
          text: page.pageContent,
          metadata: {
            documentId: documentId, // Link vector to the main document
            pageNumber: page.metadata?.loc?.pageNumber, // Optional, depending on chunker output
            chatId: chatSessionId, // Link chat ID if needed for vector search
          },
        });
        logger.debug(`🧩 Vector inserted with ID: ${vectorResult.id} for document ${documentId}`);
        // If 'documentVectors' table exists, insert mapping here
        // await runQuery(`INSERT INTO documentVectors (vectorId, documentId, pageNumber) VALUES (?, ?, ?)`, [vectorId, documentId, page.metadata?.loc?.pageNumber]);
        return vectorResult.id;
      });
      const addResults = await Promise.all(vectorInsertPromises);

      logger.info(`Added ${addResults.length} page vectors successfully for documentId: ${documentId}.`);

      // 6. Respond to the client with the created file details
      return res.status(201).json({
        success: true,
        message: "PDF uploaded and processed successfully",
        file: { // Send comprehensive file data back to client for immediate UI update
          fileId: documentId,
          name: originalFileName,
          type: req.file.mimetype,
          size: req.file.size,
          uploadedAt: new Date().toISOString(), // ISO string for precise timestamp
        },
      });
    } catch (error) {
      logger.error("❌ Error in PDF upload handling:", error);
      // Clean up partially uploaded physical file if an error occurs
      if (permanentFilePath) {
        try { await fs.unlink(permanentFilePath); logger.warn(`Cleaned up temporary file due to error: ${permanentFilePath}`); }
        catch (cleanupError) { logger.error(`Failed to clean up file ${permanentFilePath}:`, cleanupError); }
      }
      return next(new ApiError(500, "Failed to process PDF upload", [error.message]));
    }
  };
  ```
  **Priority:** HIGH

**Line(s):** 71-76
- **Issue Type:** LOGIC / MAINTAINABILITY
  **Description:** The `getUploadedFiles` endpoint currently only retrieves `fileId` and `filePath` from the `files` table. The client-side `Dashboard.jsx` (around line 199 and 240) expects more detailed file information like `name` (original filename), `type`, `size`, and `uploadTime` to display comprehensive file cards. This information is currently not stored or retrieved, leading to incomplete UI data.
  **Line(s) to Fix:** 71-76
  **Current Code:**
  ```javascript
  const files = await runQuery(
    "SELECT fileId, filePath FROM files WHERE userId = ?",
    [user.userId]
  );
  ```
  **Suggested Fix:** The `files` table (or a new `documents` table as suggested in the previous point) should store `originalFileName`, `fileSize`, `uploadedAt`, `fileType`. The `getUploadedFiles` query should then select these additional columns, potentially aliasing them to match client expectations (`name`, `size`, `type`).
  ```javascript
  const files = await runQuery(
    `SELECT fileId, originalFileName AS name, fileSize AS size, fileType AS type, uploadedAt
     FROM files WHERE userId = ?`,
    [user.userId]
  );
  ```
  **Priority:** MEDIUM

**Line(s):** 89, 92
- **Issue Type:** BUG / LOGIC / MAINTAINABILITY
  **Description:** In `deleteUploadedFiles`, the `console.log(file);` (line 92) is a debug statement that should be removed. More critically, the function only deletes the file record from the SQLite database and its associated vector from ChromaDB, but it does **not** delete the actual physical file from disk. This leads to disk space accumulation and data inconsistency.
  **Line(s) to Fix:** 89, 92 (and add file deletion logic)
  **Current Code:**
  ```javascript
  // Line 89
  if (!file) {\r\n    throw new ApiError(404, "File not found", [fileId]);\r\n  }\r\n  //delete vectorIds from chroma db\r\n  console.log(file);\r\n\r\n  await deleteVector(file[0].vectorId);\r\n\r\n  // Delete file from database\r\n  await runQuery("DELETE FROM files WHERE fileId = ?", [fileId]);\r\n  ```
  **Suggested Fix:** Remove the debug log. Add `fs.unlink` to delete the physical file. Ensure `file[0].vectorId` is correct and `deleteVector` (from ChromaDB service) is implemented to delete by `documentId` if a document has multiple vectors, or handle multiple vector deletions if the `files` table maps to document chunks.
  ```javascript
  // Add import: import fs from 'fs/promises';
  // Add import: import { deleteVectorsByDocumentId } from "../services/chromadb.service.js"; // Assuming a new function

  export const deleteUploadedFiles = async (req, res, next) => { // Add 'next' to parameters
    const userId = req.user.userId;
    const fileId = req.params.fileId;

    let filePathToDelete; // Declare outside try-catch for cleanup

    try {
      // Check if file exists and get its path
      const fileRecord = runQuery( // Assuming this returns { filePath, vectorId } synchronously or undefined
        "SELECT filePath, fileId, vectorId FROM files WHERE fileId = ? AND userId = ?",
        [fileId, userId]
      );
      if (!fileRecord) { // Corrected check for synchronous query result
        return next(new ApiError(404, "File not found or not authorized", [fileId]));
      }

      filePathToDelete = fileRecord.filePath; // Get permanent path
      const vectorIdToDelete = fileRecord.vectorId; // Single vector ID associated with this file entry

      // Log for debugging (use logger.info instead of console.log)
      logger.info(`Attempting to delete file: ${fileId} with path: ${filePathToDelete}`);

      // 1. Delete associated vectors from ChromaDB (if multiple vectors per file, need a batch delete based on fileId)
      // If 'fileId' refers to a document, and documents can have many vectors, use `deleteVectorsByDocumentId`.
      // Otherwise, if this `file` entry IS a single vector:
      await deleteVector(vectorIdToDelete); // Assuming deleteVector can handle one specific vector ID
      logger.info(`Vector ${vectorIdToDelete} deleted from ChromaDB for file ${fileId}.`);


      // 2. Delete file record from database
      await runQuery("DELETE FROM files WHERE fileId = ?", [fileId]);
      logger.info(`File record ${fileId} deleted from database.`);

      // 3. Delete physical file from disk
      await fs.unlink(filePathToDelete);
      logger.info(`Physical file ${filePathToDelete} deleted from disk.`);

      return res.json({
        success: true,
        message: "File deleted successfully",
      });
    } catch (error) {
      logger.error("❌ Error in deleting uploaded files:", error);
      // Attempt to clean up physical file if an error occurs mid-process
      if (filePathToDelete) {
        try { await fs.unlink(filePathToDelete); logger.warn(`Cleaned up partially deleted file due to error: ${filePathToDelete}`); }
        catch (cleanupError) { logger.error(`Failed to clean up file ${filePathToDelete}:`, cleanupError); }
      }
      return next(new ApiError(500, "Failed to delete uploaded files", [error.message]));
    }
  };
  ```
  **Priority:** HIGH

**No Line(s):** (New Endpoint)
- **Issue Type:** BUG / LOGIC / MAINTAINABILITY
  **Description:** There is no API endpoint to facilitate the download of uploaded files. The client-side "Download" button is non-functional because it has no server endpoint to request the file from.
  **Line(s) to Fix:** N/A (requires new function and route)
  **Current Code:** (No existing code for file download endpoint)
  **Suggested Fix:** Implement a new controller function and route (e.g., `GET /api/v1/upload/download/:fileId`) to handle file downloads.
  ```javascript
  // server/src/controllers/upload.controller.js
  // Ensure path and fs.promises are imported
  // import path from 'path';
  // import fs from 'fs/promises';

  export const downloadFile = async (req, res, next) => { // Add 'next' to parameters
    const { fileId } = req.params;
    const userId = req.user.userId;

    try {
      const fileRecord = runQuery( // Synchronous query
        "SELECT filePath, originalFileName FROM files WHERE fileId = ? AND userId = ?",
        [fileId, userId]
      );

      if (!fileRecord) { // Check if file found and user authorized
        return next(new ApiError(404, "File not found or not authorized", [fileId]));
      }

      const filePath = fileRecord.filePath;
      const fileName = fileRecord.originalFileName;

      // Ensure file exists on disk before attempting to send
      await fs.access(filePath); // Checks if file exists and process has read permissions

      res.download(filePath, fileName, (err) => {
        if (err) {
          logger.error("❌ Error downloading file:", err);
          // Check if headers were already sent to avoid 'Cannot set headers after they are sent'
          if (!res.headersSent) {
            return next(new ApiError(500, "Failed to download file", [err.message]));
          }
        }
      });
    } catch (error) {
      logger.error("❌ Error in file download handling:", error);
      return next(new ApiError(500, "Failed to download file", [error.message]));
    }
  };
  ```
  **Priority:** HIGH

**File:** `server/src/controllers/user.controller.js`
**Line(s)::** 19
- **Issue Type:** STYLE / MAINTAINABILITY
  **Description:** `console.error("Error fetching chat history:", error);` is used for logging errors. For consistency and better production logging, all logging should go through the `logger` utility (already imported on line 2).
  **Line(s) to Fix:** 19
  **Current Code:** `console.error("Error fetching chat history:", error);`
  **Suggested Fix:**
  ```javascript
  logger.error("Error fetching chat history:", error);
  ```
  **Priority:** LOW

**File:** `server/src/database/chroma.db.js`
**Line(s)::** 3
- **Issue Type:** STYLE / MAINTAINABILITY
  **Description:** The import path `../../config/contants.js` contains a typo (`contants` instead of `constants`). This should be corrected for proper spelling and readability.
  **Line(s) to Fix:** 3
  **Current Code:** `import { CHROMADB_API_KEY } from "../../config/contants.js";`
  **Suggested Fix:** Correct the typo.
  ```javascript
  import { CHROMADB_API_KEY } from "../../config/constants.js"; // Corrected typo
  ```
  **Priority:** MEDIUM

**Line(s)::** 7
- **Issue Type:** SECURITY
  **Description:** The `apiKey` for ChromaDB is hardcoded directly in the source code (`"ck-CnDk3Frr5kzY6VjgF3nNaFLVTzjq7L8XnobPLBtn3bcR"`). This is a severe security vulnerability. Hardcoding credentials makes them easily discoverable, especially if the code is committed to a public repository or deployed insecurely. The `CHROMADB_API_KEY` environment variable is already imported (from line 3) but not used.
  **Line(s) to Fix:** 7
  **Current Code:** `apiKey: "ck-CnDk3Frr5kzY6VjgF3nNaFLVTzjq7L8XnobPLBtn3bcR",`
  **Suggested Fix:** Use the imported environment variable `CHROMADB_API_KEY`.
  ```javascript
  apiKey: CHROMADB_API_KEY, // Use the imported API key from configuration
  ```
  **Priority:** HIGH

**Line(s):** 5-18, 59-61, 80-82
- **Issue Type:** LOGIC / ERROR_HANDLING
  **Description:**
    1.  **`initChroma` (Lines 5-18):** The `initChroma` function lacks a `try...catch` block around the asynchronous operations (`new CloudClient` and `client.getOrCreateCollection`). If any of these operations fail (e.g., due to network issues, invalid credentials, or service unavailability), the promise returned by `initChroma` will reject, leading to an unhandled promise rejection that will crash the Node.js process when the top-level `await` is used (line 21).
    2.  **`addVector` (Lines 59-61):** The `catch` block for `addVector` only logs the error (`console.error`) but does not re-throw it or return an explicit error indicator. This leads to silent failures, where the `addVector` call might fail but the calling code (e.g., `upload.controller.js`) continues as if successful, leading to data inconsistencies.
    3.  **`deleteVector` (Lines 80-82):** Similar to `addVector`, the `catch` block for `deleteVector` only logs the error but does not re-throw or propagate it, leading to silent failures.
  **Line(s) to Fix:** 5-18, 59-61, 80-82
  **Current Code:**
  ```javascript
  // Lines 5-18 (initChroma)
  async function initChroma() {\r\n    const client = new CloudClient({ /* ... */ });\r\n    logger.info("ChromaDB CloudClient created.");\r\n    const collection = await client.getOrCreateCollection({ /* ... */ });\r\n    logger.info("ChromaDB collection ready.");\r\n    return { client, collection };\r\n  }\r\n  // Lines 59-61 (addVector catch)\r\n  } catch (error) {\r\n    console.error("Error adding vector:", error);\r\n  }\r\n  // Lines 80-82 (deleteVector catch)\r\n  } catch (error) {\r\n    console.error("Error deleting vector:", error);\r\n  }\r\n  ```
  **Suggested Fix:** Implement `try...catch` blocks for all asynchronous operations and ensure errors are properly propagated (re-thrown).
  ```javascript
  // For initChroma:
  async function initChroma() {
    try {
      const client = new CloudClient({
        apiKey: CHROMADB_API_KEY, // Use the environment variable
        tenant: "11489e26-4f87-43cf-9a04-80b0a61aa74e",
        database: "notebook-lm",
      });
      logger.info("ChromaDB CloudClient created.");

      const collection = await client.getOrCreateCollection({
        name: "notebook-lm",
      });
      logger.info("ChromaDB collection ready.");

      return { client, collection };
    } catch (error) {
      logger.error("Failed to initialize ChromaDB:", error.message || error);
      throw error; // Re-throw to propagate the error for higher-level handling
    }
  }

  // For addVector (Line 59-61):
  } catch (error) {
    logger.error("Error adding vector to ChromaDB:", error); // Use logger
    throw new Error(`Failed to add vector: ${error.message}`); // Re-throw with a meaningful message
  }

  // For deleteVector (Line 80-82):
  } catch (error) {
    logger.error("Error deleting vector from ChromaDB:", error); // Use logger
    throw new Error(`Failed to delete vector: ${error.message}`); // Re-throw
  }
  ```
  **Priority:** HIGH

**Line(s)::** 21
- **Issue Type:** LOGIC / MAINTAINABILITY
  **Description:** Using top-level `await` for database initialization (`export const { client, collection } = await initChroma();`) is syntactically valid but can lead to immediate application termination if `initChroma` fails and throws an error (even with the `try-catch` added inside `initChroma`, the re-throw will still cause an unhandled rejection at this level). This makes it harder for the main application entry point (`server.js`) to manage and report critical startup failures gracefully.
  **Line(s) to Fix:** 21
  **Current Code:** `export const { client, collection } = await initChroma();`
  **Suggested Fix:** Separate the export and initialization. Handle the promise rejection explicitly to control application startup.
  ```javascript
  let clientInstance;
  let collectionInstance;

  try {
    ({ client: clientInstance, collection: collectionInstance } = await initChroma());
  } catch (error) {
    logger.error("Application failed to initialize critical ChromaDB components. Exiting.", error);
    process.exit(1); // Exit if DB connection is critical for application startup
  }

  export const client = clientInstance;
  export const collection = collectionInstance;
  ```
  **Priority:** MEDIUM

**Line(s)::** 71-73
- **Issue Type:** LOGIC / CONSISTENCY
  **Description:** The validation logic for `embedding` in `searchVector` (`!embedding.every((x) => typeof x === "number")`) is less strict than the `normalizeEmbedding` function, which additionally checks for `Number.isFinite(x)`. Passing `NaN` or `Infinity` values could lead to unexpected behavior or errors in ChromaDB. For consistency and robustness, `searchVector` should validate embeddings with the same rigor as `addVector`. The best approach is to reuse `normalizeEmbedding`.
  **Line(s) to Fix:** 71-73
  **Current Code:**
  ```javascript
  if (
    !Array.isArray(embedding) ||
    !embedding.every((x) => typeof x === "number")
  ) {
    throw new Error("Invalid embedding: must be an array of numbers");
  }
  ```
  **Suggested Fix:** Reuse `normalizeEmbedding` for consistent validation and normalization.
  ```javascript
  export const searchVector = async (embedding, userId, n_results = 2) => {
    const queryEmbedding = normalizeEmbedding(embedding); // Use normalizeEmbedding for full validation

    return await collection.query({
      queryEmbeddings: [queryEmbedding], // Use the normalized embedding
      n_results,
      where: { userId: { $eq: userId } }, // search restricted to that user
    });
  };
  ```
  **Priority:** HIGH

**Line(s):** 65, 90
- **Issue Type:** STYLE / DEBUG
  **Description:** `console.log(res);` in `addVector` (line 65) and `console.log("🗑️ Vector deleted:", res);` in `deleteVector` (line 90) are debug statements that should be removed from production code.
  **Line(s) to Fix:** 65, 90
  **Current Code:**
  ```javascript
  // Line 65: console.log(res);
  // Line 90: console.log("🗑️ Vector deleted:", res);
  ```
  **Suggested Fix:** Remove the lines or replace with `logger.debug` or `logger.info`.
  ```javascript
  // (Remove these lines)
  ```
  **Priority:** LOW

**File:** `server/src/database/sqlLite.db.js`
**Line(s)::** 4, 6, 20
- **Issue Type:** STYLE / DEBUG
  **Description:** `console.log` statements are used for debugging during database initialization (lines 4, 6) and table creation (line 20). These should be replaced with the `logger` utility for consistent and configurable logging in production environments.
  **Line(s) to Fix:** 4, 6, 20
  **Current Code:**
  ```javascript
  console.log("Initializing database...");
  export const db = new Database("./notebook-lm.sqlite");
  console.log(`Database path: ${db.name}`);
  // ...
  console.log("Users table created or already exists.");
  ```
  **Suggested Fix:** Use `logger.info` instead.
  ```javascript
  import { logger } from "../utils/logger.js"; // Ensure logger is imported

  logger.info("Initializing database...");
  export const db = new Database("./notebook-lm.sqlite");
  logger.info(`Database path: ${db.name}`);
  // ...
  logger.info("Users table created or already exists.");
  ```
  **Priority:** LOW

**Line(s)::** 52, 60
- **Issue Type:** STYLE / DEBUG
  **Description:** The commented-out `//console.log(`Executing SQL: ${sql}`);` (line 52) and `//console.log(stmt.run(params));` (line 60) are debug statements that should be removed from the codebase.
  **Line(s) to Fix:** 52, 60
  **Current Code:**
  ```javascript
  //console.log(`Executing SQL: ${sql}`);
  // ...
  //console.log(stmt.run(params));
  ```
  **Suggested Fix:** Remove the commented-out lines.
  ```javascript
  // (Remove these lines)
  ```
  **Priority:** LOW

**File:** `server/src/middlewares/auth.middleware.js`
**Line(s)::** 2
- **Issue Type:** STYLE / MAINTAINABILITY
  **Description:** The import path `../../config/contants.js` contains a typo (`contants` instead of `constants`). This should be corrected for proper spelling and readability.
  **Line(s) to Fix:** 2
  **Current Code:** `import { JWT_SECRET } from "../../config/contants.js";`
  **Suggested Fix:** Correct the typo.
  ```javascript
  import { JWT_SECRET } from "../../config/constants.js"; // Corrected typo
  ```
  **Priority:** MEDIUM

**Line(s)::** 6, 14
- **Issue Type:** STYLE / DEBUG
  **Description:** `console.log(token);` (line 6) and `console.log("in mid", req.user);` (line 14) are debug outputs. They should be removed from production code as they can add noise to server logs and potentially expose sensitive information (JWT token, user details).
  **Line(s) to Fix:** 6, 14
  **Current Code:**
  ```javascript
  console.log(token);
  // ...
  console.log("in mid", req.user);
  ```
  **Suggested Fix:** Remove the lines.
  ```javascript
  // (Remove these lines)
  ```
  **Priority:** LOW

**Line(s)::** 17-19
- **Issue Type:** MAINTAINABILITY / LOGIC
  **Description:** When a token verification fails for reasons other than expiration, the server currently returns a generic "Invalid token" message. While this is good for security (not exposing internal errors to the client), the actual `error` object contains valuable debugging information that is not logged on the server-side. Logging this error (using `console.error` or `logger.error`) will greatly assist in diagnosing and troubleshooting issues related to token validation without affecting the client's response.
  **Line(s) to Fix:** 17-19
  **Current Code:**
  ```javascript
  if (error.name === "TokenExpiredError") {
    return res.status(401).json({ success: false, error: "Token expired" });
  }
  return res.status(401).json({ success: false, error: "Invalid token" });
  ```
  **Suggested Fix:** Log the error details before sending a generic response.
  ```javascript
  if (error.name === "TokenExpiredError") {
    return res.status(401).json({ success: false, error: "Token expired" });
  }
  console.error("JWT verification failed:", error.message || error); // Log the actual error for server-side debugging
  return res.status(401).json({ success: false, error: "Invalid token" });
  ```
  **Priority:** MEDIUM

**File:** `server/src/routes/upload.route.js`
**Line(s):** N/A (requires new routes)
- **Issue Type:** BUG / LOGIC / MAINTAINABILITY
  **Description:** The `upload.route.js` defines routes for file upload (`POST /`), file listing (`GET /`), and file deletion (`DELETE /:fileId`). However, it currently lacks a route for downloading files. The client-side `Dashboard.jsx` includes a "Download" button that is non-functional due to the absence of this backend endpoint. This represents a functional gap in the API design.
  **Line(s) to Fix:** N/A (requires adding new routes)
  **Current Code:** (No existing code for file download route)
  **Suggested Fix:** Add a `GET /download/:fileId` route and ensure it's protected by `verifyJwtToken`, assuming a `downloadFile` controller function is implemented.
  ```javascript
  import express from "express";
  import {
    handlePdfUpload,
    getUploadedFiles,
    deleteUploadedFiles,
    // Add this when implemented in upload.controller.js:
    // downloadFile,
  } from "../controllers/upload.controller.js";
  import { upload } from "../services/multer.service.js";
  import { verifyJwtToken } from "../middlewares/auth.middleware.js";

  const router = express.Router();

  router.post("/", verifyJwtToken, upload.single("pdfFile"), handlePdfUpload);
  router.get("/", verifyJwtToken, getUploadedFiles);
  router.delete("/:fileId", verifyJwtToken, deleteUploadedFiles);
  // Add new route for download:
  // router.get("/download/:fileId", verifyJwtToken, downloadFile);

  export default router;
  ```
  **Priority:** MEDIUM

**File:** `server/src/routes/user.route.js`
**Line(s)::** 9
- **Issue Type:** SECURITY / LOGIC
  **Description:** The `router.get("/chatHistory", getChatHistory);` route is missing the `verifyJwtToken` middleware. This is a significant security vulnerability as it allows any unauthenticated user to access the chat history of any user if they can guess or infer a `userId`, or if the endpoint implicitly derives it from an unauthenticated session. All endpoints returning user-specific data must be protected.
  **Line(s) to Fix:** 9
  **Current Code:** `router.get("/chatHistory", getChatHistory);`
  **Suggested Fix:** Add the `verifyJwtToken` middleware to this route.
  ```javascript
  router.get("/chatHistory", verifyJwtToken, getChatHistory);
  ```
  **Priority:** HIGH

**File:** `server/src/services/chromadb.service.js`
**Line(s)::** 2
- **Issue Type:** STYLE / MAINTAINABILITY
  **Description:** The `uuid` import is aliased as `uuid` (`import { v4 as uuid } from "uuid";`), but the common convention and usage within this codebase (e.g., in `upload.controller.js`) is `uuidv4()`. While it works, it's inconsistent and can be confusing. It's better to align the alias with its common usage.
  **Line(s) to Fix:** 2
  **Current Code:** `import { v4 as uuid } from "uuid";`
  **Suggested Fix:** Alias it consistently to `uuidv4`.
  ```javascript
  import { v4 as uuidv4 } from "uuid"; // Use uuidv4 consistently
  ```
  **Priority:** LOW

**Line(s)::** 36-37
- **Issue Type:** BUG / LOGIC
  **Description:** The `normalizeEmbedding` function validates that all elements are numbers and finite. However, it does not explicitly check if the `emb` array itself is empty. ChromaDB (and many embedding models) typically expect non-empty embeddings with a specific dimension. An empty array `[]` would pass existing checks (`!Array.isArray(emb)` is false, and `!emb.every(...)` is false because `every` on an empty array returns `true`), potentially leading to errors or unexpected behavior when passed to `collection.add`.
  **Line(s) to Fix:** 36-37
  **Current Code:**
  ```javascript
  if (!Array.isArray(emb)) {
    throw new TypeError("embedding must be an array");
  }
  if (!emb.every((x) => typeof x === "number" && Number.isFinite(x))) {
    throw new TypeError("embedding contains non-numeric values");
  }
  return emb;
  ```
  **Suggested Fix:** Add a check to ensure the embedding array is not empty.
  ```javascript
  if (!Array.isArray(emb)) {
    throw new TypeError("embedding must be an array");
  }
  if (emb.length === 0) { // Added check for empty array
    throw new TypeError("embedding cannot be empty");
  }
  if (!emb.every((x) => typeof x === "number" && Number.isFinite(x))) {
    throw new TypeError("embedding contains non-numeric values");
  }
  return emb;
  ```
  **Priority:** MEDIUM

**File:** `server/src/routes/user.route.js`
**Line(s):** 9
- **Issue Type:** SECURITY / LOGIC
  **Description:** The `router.get("/chatHistory", getChatHistory);` route is missing the `verifyJwtToken` middleware. This allows any unauthenticated user to access the chat history, which is a significant security vulnerability.
  **Line(s) to Fix:** 9
  **Current Code:**
  ```javascript
  router.get("/chatHistory", getChatHistory);
  ```
  **Suggested Fix:** Apply the `verifyJwtToken` middleware.
  ```javascript
  router.get("/chatHistory", verifyJwtToken, getChatHistory);
  ```
  **Priority:** HIGH

**File:** `server/src/utils/jwtMaker.js`
**Line(s)::** 4
- **Issue Type:** BUG / LOGIC / MAINTAINABILITY
  **Description:** The `createJwtToken` function is currently written to accept two separate arguments (`userEmail`, `userId`), but its internal logic for `accessTokenPayload` and `refreshTokenPayload` implicitly assumes it receives a single `payload` object with `email` and `userId` properties. This mismatch means the function is creating JWTs with malformed payloads, as `userEmail` (the first argument) is being treated as the entire `payload` object within the function, leading to `payload.email` and `payload.userId` being `undefined`.
  **Line(s) to Fix:** 4
  **Current Code:** `export const createJwtToken = (userEmail, userId) => {`
  **Suggested Fix:** Adjust the function signature to correctly accept a single payload object, which is how it's intended to be used in `auth.controller.js` after the suggested fixes there.
  ```javascript
  export const createJwtToken = (payload) => { // Accept single payload object
    const accessTokenPayload = {
      email: payload.email, // Access properties from the payload object
      userId: payload.userId,
      type: "access",
    };

    const refreshTokenPayload = {
      email: payload.email,
      userId: payload.userId,
      type: "refresh",
    };
  // ... rest of the function ...
  };
  ```
  **Priority:** HIGH

**Line(s):** 28
- **Issue Type:** STYLE / MAINTAINABILITY
  **Description:** The line `//return token;` is commented out. It is also unreachable code because the function has already returned on the preceding line (`return { accessToken, refreshToken };`). Commented-out unreachable code adds unnecessary clutter and confusion to the codebase.
  **Line(s) to Fix:** 28
  **Current Code:** `//return token;`
  **Suggested Fix:** Remove the commented-out line.
  ```javascript
  // (Remove this line)
  ```
  **Priority:** LOW

**Line(s):** 29-31
- **Issue Type:** BUG / ERROR_HANDLING
  **Description:** The `catch` block for the `jwt.sign` operations only logs the error to the console (`console.log(error);`) but does not re-throw it or return an explicit error indicator (e.g., `null`). This means that if token creation fails for any reason, the `createJwtToken` function will implicitly return `undefined` to its caller without signaling the failure. This can lead to silent failures and hard-to-debug issues elsewhere in the application (e.g., in `auth.controller.js`, where it expects valid tokens to be returned).
  **Line(s) to Fix:** 29-31
  **Current Code:**
  ```javascript
  } catch (error) {\r\n    console.log(error);\r\n  }\r\n  ```
  **Suggested Fix:** Re-throw the error to ensure calling functions handle the failure explicitly. Use `console.error` for errors.
  ```javascript
  } catch (error) {
    console.error("Error creating JWT token:", error); // Use console.error for errors
    throw error; // Re-throw the error to ensure calling functions handle the failure
  }
  ```
  **Priority:** HIGH