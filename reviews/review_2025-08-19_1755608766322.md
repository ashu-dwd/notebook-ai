**Overall Review Summary:**
- **Total Issues Found:** 11
- **Critical Issues:** 3 (Bugs: Unhandled async errors, incorrect `await` usage, file persistence)
- **Code Quality Score:** 6/10
- **Approval Status:** NEEDS_CHANGES
- **Key Recommendations:**
    1. Implement proper asynchronous error handling middleware for Express routes.
    2. Correctly `await` database operations and handle their results.
    3. Ensure uploaded files are deleted after processing to prevent disk space issues and security risks.

---

### File-by-File Review

**File: `server/.gitignore`**
**Line(s):** 1-28
- **Issue Type:** STYLE
  **Description:** The `.gitignore` file is generally well-structured. However, the specific pattern `report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json` for logs is very specific. While functional, a more general pattern might be `report.*.json` or `*.json` under a `logs/` directory if all such reports are logs. This is minor.
  **Line(s) to Fix:** N/A
  **Current Code:**
  ```gitignore
  report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json
  ```
  **Suggested Fix:** This is an optional improvement, no direct fix needed unless the pattern is too restrictive. If this pattern is for specific log files, it's fine.
  **Priority:** LOW

**File: `server/src/controllers/chat.controller.js`**
**Line(s):** 1
- **Issue Type:** MAINTAINABILITY
  **Description:** The import `import { success } from "zod";` is present but `success` is not used anywhere in the file. This is a dead import and should be removed for cleaner code.
  **Line(s) to Fix:** 1
  **Current Code:**
  ```javascript
  import { success } from "zod";
  ```
  **Suggested Fix:**
  ```javascript
  // Remove the unused import
  // import { success } from "zod";
  ```
  **Priority:** LOW

**Line(s):** 15-16
- **Issue Type:** STYLE
  **Description:** There are commented-out `console.log` statements. While useful during development, they should be removed before committing production code to avoid clutter and ensure only structured logging (via `logger`) is used.
  **Line(s) to Fix:** 15-16
  **Current Code:**
  ```javascript
      //console.log(embeddings.length);
      const results = await searchVector(embeddings);
      //console.log(results);
  ```
  **Suggested Fix:**
  ```javascript
      const results = await searchVector(embeddings);
  ```
  **Priority:** LOW

**Line(s):** 22-24
- **Issue Type:** BUG / LOGIC
  **Description:** In an asynchronous Express route handler, throwing an `ApiError` directly from within a `try-catch` block will not be caught by Express's default error handling middleware unless a specific `catchAll` middleware is set up, or `next(error)` is called. This can lead to unhandled promise rejections or server crashes instead of proper error responses.
  **Line(s) to Fix:** 22-24
  **Current Code:**
  ```javascript
    console.log(error);
    logger.error("Error in chatWithPdf:", error.message);
    throw new ApiError("Failed to process chat request", 500);
  ```
  **Suggested Fix:** You should pass the error to the `next` middleware function to ensure it's handled by your Express error handling setup. Also, replace `console.log` with `logger.error` for consistency.
  ```javascript
    logger.error("Error in chatWithPdf:", error.message);
    // Pass the error to the next middleware for centralized error handling
    return next(new ApiError("Failed to process chat request", 500));
  ```
  **Priority:** HIGH

**Line(s):** 22
- **Issue Type:** STYLE
  **Description:** `console.log(error);` is used for logging errors. For consistency and better production logging, all logging should go through the `logger` utility.
  **Line(s) to Fix:** 22
  **Current Code:**
  ```javascript
    console.log(error);
  ```
  **Suggested Fix:**
  ```javascript
    // Use the logger utility instead of console.log
    // The line below it already uses logger.error, so this line can just be removed
    // logger.error("Detailed error object:", error); // Or just remove if `error.message` is sufficient below.
  ```
  **Priority:** MEDIUM

**File: `server/src/controllers/upload.controller.js`**
**Line(s):** 10-12
- **Issue Type:** BUG / LOGIC
  **Description:** The `runQuery` function is called without `await`. Database operations are almost always asynchronous and return a Promise. `user` will therefore be a Promise object, not the resolved user data. This is a critical bug.
  **Line(s) to Fix:** 10-12
  **Current Code:**
  ```javascript
  const user = runQuery("SELECT userId FROM userData WHERE email = ? LIMIT 1", [
    req.user.email,
  ]);
  ```
  **Suggested Fix:**
  ```javascript
  const user = await runQuery("SELECT userId FROM userData WHERE email = ? LIMIT 1", [
    req.user.email,
  ]);
  ```
  **Priority:** HIGH

**Line(s):** 13
- **Issue Type:** BUG / LOGIC
  **Description:** Due to the missing `await` in the previous issue, `user` is a Promise object. A Promise object is always truthy, so the check `if (!user)` will *never* evaluate to true, even if the database query resolves to `null` or `undefined` (meaning no user was found). This prevents the `ApiError` for "User not found" from ever being thrown.
  **Line(s) to Fix:** 13
  **Current Code:**
  ```javascript
  console.log("User found:", user);
  try {
    logger.info("Uploaded file:", req.file);

    // 1️⃣ Get userId from email

    if (!user) {
      throw new ApiError(404, "User not found", [req.user.email]);
    }
  ```
  **Suggested Fix:** This issue is resolved by correctly awaiting `runQuery` (see previous fix). After `await`, the `if (!user)` check will correctly identify if no user was found.
  ```javascript
  console.log("User found:", user); // This console.log should also be replaced with logger.info
  try {
    logger.info("Uploaded file:", req.file);

    // 1️⃣ Get userId from email

    // After 'await' for runQuery, 'user' will be the resolved value
    if (!user || user.userId === undefined) { // Added user.userId === undefined for explicit check if userId is expected property
      return next(new ApiError(404, "User not found", [req.user.email]));
    }
  ```
  **Priority:** HIGH

**Line(s):** 13, 39, 42-44
- **Issue Type:** STYLE
  **Description:** Similar to `chat.controller.js`, `console.log` statements are used for debugging purposes. These should be replaced with `logger.info` or removed for production code clarity and consistent logging.
  **Line(s) to Fix:** 13, 39, 42-44
  **Current Code:**
  ```javascript
  console.log("User found:", user);
  // ...
          console.log("🧩 Vector inserted with ID:", vectorResult.id);
          // console.log(typeof vectorResult.id);
          // console.log(typeof user.userId);
          // console.log(typeof req.file.path);
  ```
  **Suggested Fix:**
  ```javascript
  logger.info("User found:", user);
  // ...
          logger.info("🧩 Vector inserted with ID:", vectorResult.id);
          // Remove commented out console.logs
  ```
  **Priority:** MEDIUM

**Line(s):** 46-51
- **Issue Type:** MAINTAINABILITY / PERFORMANCE
  **Description:** The `runQuery` for `INSERT INTO files` is called inside the `pages.map` loop without `await` and then the entire `Promise.all` waits for it. While `Promise.all` ensures all map callbacks complete, this particular `runQuery` (if it's truly asynchronous and returns a Promise) should be `await`ed or explicitly pushed to an array of Promises to be resolved by `Promise.all`. If `runQuery` is synchronous, running it inside an async map function is inefficient and misleading. Assuming it's an async operation.
  **Line(s) to Fix:** 46-51
  **Current Code:**
  ```javascript
          runQuery(
            `
    INSERT INTO files (userId, filePath, vectorId)
    VALUES (?, ?, ?)
  `,
            [user.userId, req.file.path, vectorResult.id]
          );
  ```
  **Suggested Fix:** Add `await` to `runQuery`. If this `runQuery` returns a value, you might want to capture it.
  ```javascript
          await runQuery(
            `
    INSERT INTO files (userId, filePath, vectorId)
    VALUES (?, ?, ?)
  `,
            [user.userId, req.file.path, vectorResult.id]
          );
  ```
  **Priority:** MEDIUM

**Line(s):** 62-63
- **Issue Type:** BUG / LOGIC
  **Description:** Similar to `chat.controller.js`, throwing `ApiError` directly in an async Express route handler will not be caught by standard Express error handling middleware without a `next(error)` call.
  **Line(s) to Fix:** 62-63
  **Current Code:**
  ```javascript
    logger.error("❌ Error in PDF upload handling:", error);
    throw new ApiError(500, "Failed to process PDF upload", [error.message]);
  ```
  **Suggested Fix:** Pass the error to the `next` middleware.
  ```javascript
    logger.error("❌ Error in PDF upload handling:", error);
    return next(new ApiError(500, "Failed to process PDF upload", [error.message]));
  ```
  **Priority:** HIGH

**Line(s):** Entire file context
- **Issue Type:** MAINTAINABILITY / SECURITY
  **Description:** The uploaded file, located at `req.file.path`, is processed (chunked, embedded, indexed). However, there's no code to delete this temporary file after it has been successfully processed or if an error occurs. Leaving temporary files on the disk can lead to accumulation, consuming disk space, and potentially exposing sensitive data if the upload directory is publicly accessible.
  **Line(s) to Fix:** N/A (requires addition to the `try` block and `finally` block or error handler)
  **Current Code:** No file deletion logic.
  **Suggested Fix:** Add a `finally` block to the `try-catch` to ensure the file is deleted regardless of success or failure. You'll need to import `fs` for this.
  ```javascript
  import fs from 'fs/promises'; // Import fs.promises for async file operations
  // ... other imports ...

  export const handlePdfUpload = async (req, res, next) => { // Add 'next' to parameters
    const user = await runQuery("SELECT userId FROM userData WHERE email = ? LIMIT 1", [
      req.user.email,
    ]);
    logger.info("User found:", user); // Changed from console.log
    let filePathToDelete = req.file?.path; // Store file path for deletion

    try {
      logger.info("Uploaded file:", req.file);

      if (!user || user.userId === undefined) {
        return next(new ApiError(404, "User not found", [req.user.email]));
      }

      const pages = await chunkPdf(req.file.path);

      const addResults = await Promise.all(
        pages.map(async (page) => {
          const embedding = await getEmbeddings(page.pageContent);
          const id = uuidv4();
          const vectorResult = await addVector({
            id,
            embedding,
            text: page.pageContent,
            metadata: page.metadata,
          });

          logger.info("🧩 Vector inserted with ID:", vectorResult.id); // Changed from console.log

          await runQuery( // Added await
            `
    INSERT INTO files (userId, filePath, vectorId)
    VALUES (?, ?, ?)
  `,
            [user.userId, req.file.path, vectorResult.id]
          );
          return vectorResult.id;
        })
      );

      logger.info(`Added ${addResults.length} page vectors successfully.`);
      return res.json({
        success: true,
        count: addResults.length,
        message: "PDF uploaded and processed successfully",
      });
    } catch (error) {
      logger.error("❌ Error in PDF upload handling:", error);
      // Pass the error to the next middleware
      return next(new ApiError(500, "Failed to process PDF upload", [error.message]));
    } finally {
      // Ensure file is deleted whether successful or not
      if (filePathToDelete) {
        try {
          await fs.unlink(filePathToDelete);
          logger.info(`Successfully deleted temporary file: ${filePathToDelete}`);
        } catch (unlinkError) {
          logger.error(`Failed to delete temporary file ${filePathToDelete}:`, unlinkError);
        }
      }
    }
  };
  ```
  **Priority:** HIGH