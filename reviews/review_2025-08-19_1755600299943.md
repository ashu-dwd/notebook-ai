```
### File-by-File Review

**File:** `server/src/database/sqlLite.db.js`
**Line(s):** 4
-   **Issue Type:** MAINTAINABILITY
    **Description:** The database file path is hardcoded. This makes the application inflexible for different deployment environments (e.g., development, testing, production) where different database instances or paths might be required.
    **Line(s) to Fix:** 4
    **Current Code:** `export const db = new Database("mydb.sqlite");`
    **Suggested Fix:** `export const db = new Database(process.env.DATABASE_PATH || "mydb.sqlite"); // Use an environment variable for configuration`
    **Priority:** MEDIUM

**Line(s):** 5
-   **Issue Type:** STYLE / MAINTAINABILITY
    **Description:** Logging the exact database path using `console.log` on every application startup can be noisy and is not ideal for production environments. For better log management, consider integrating a dedicated logging library (e.g., Winston, Pino) with configurable log levels.
    **Line(s) to Fix:** 5
    **Current Code:** `console.log("Database path: mydb.sqlite");`
    **Suggested Fix:** `// Consider integrating a proper logging library (e.g., Winston, Pino) or remove this for production readiness.`
    **Priority:** LOW

**Line(s):** 8, 19, 30
-   **Issue Type:** STYLE / MAINTAINABILITY
    **Description:** Comments are written in Hindi. While this might be understood by the current team, for broader collaboration, open-source contributions, or future maintainers, English is the universally accepted standard for code comments in professional software development. Consistency in language improves readability and maintainability.
    **Line(s) to Fix:** 8, 19, 30
    **Current Code:**
    ```javascript
    // Agar table pehle se nahi hai to ek dummy bana dete hain
    // Agar query SELECT hai to all() ya get() use karenge
    // INSERT/UPDATE/DELETE ke liye run()
    ```
    **Suggested Fix:**
    ```javascript
    // If the table does not exist, create it
    // For SELECT queries, use all() or get()
    // Use run() for INSERT/UPDATE/DELETE queries
    ```
    **Priority:** MEDIUM

**Line(s):** 11, 23, 33
-   **Issue Type:** PERFORMANCE / LOGIC / BEST PRACTICE
    **Description:** In SQLite, a column defined as `INTEGER PRIMARY KEY` automatically implies auto-incrementing behavior (it becomes an alias for the internal `ROWID` and is guaranteed to be unique and increasing). Explicitly adding `AUTOINCREMENT` introduces a small overhead (slower performance, larger database files) by preventing the reuse of ROWIDs from deleted rows. It is rarely needed unless strict non-reusing of IDs is a specific requirement (e.g., for syncing with external systems).
    **Line(s) to Fix:** 11, 23, 33
    **Current Code:**
    ```sql
    userId INTEGER PRIMARY KEY AUTOINCREMENT,\n    chatId INTEGER PRIMARY KEY AUTOINCREMENT,\n    fileId INTEGER PRIMARY KEY AUTOINCREMENT,
    ```
    **Suggested Fix:**
    ```sql
    -- For userData table
    userId INTEGER PRIMARY KEY,
    -- For chats table
    chatId INTEGER PRIMARY KEY,
    -- For files table
    fileId INTEGER PRIMARY KEY,
    ```
    **Priority:** MEDIUM

**Line(s):** 14
-   **Issue Type:** SECURITY
    **Description:** Storing user passwords directly as plain text (`password TEXT NOT NULL`) is a critical security vulnerability. If the database is ever compromised, all user passwords would be exposed, leading to severe risks like identity theft and credential stuffing attacks. Passwords must always be hashed using a strong, one-way, and computationally expensive hashing algorithm (e.g., bcrypt, Argon2) before storage. This needs to be handled in the application logic before saving the password.
    **Line(s) to Fix:** 14
    **Current Code:** `password TEXT NOT NULL,`
    **Suggested Fix:**
    ```sql
    -- The database schema itself might not change the `TEXT` type, but the
    -- *application logic* must ensure that a strong hash of the password
    -- (e.g., bcrypt hash) is stored here, not the plain text password.
    password TEXT NOT NULL -- This column MUST store strong password hashes (e.g., bcrypt), NOT plain text!
    ```
    **Priority:** HIGH

**Line(s):** 18
-   **Issue Type:** MAINTAINABILITY / STYLE
    **Description:** There's inconsistent logging for table creation. Only the "Users table created or already exists." message is logged, while similar messages are missing for the "Chats" and "Files" tables. For better clarity and debugging during application startup, it's good practice to consistently log the status of all significant initialization steps.
    **Line(s) to Fix:** 18
    **Current Code:** `console.log("Users table created or already exists.");`
    **Suggested Fix:**
    ```javascript
    console.log("Users table created or already exists.");
    // Add similar logs for other tables for consistency:
    // console.log("Chats table created or already exists.");
    // console.log("Files table created or already exists.");
    ```
    **Priority:** LOW

**Line(s):** 40-44
-   **Issue Type:** LOGIC / MAINTAINABILITY / ARCHITECTURE
    **Description:** The `runQuery` function attempts to be generic but uses brittle string-matching (`.startsWith("select")` and `.includes("limit 1")`) to determine the database operation (single row, multiple rows, or command). This approach is fragile; it can break with slightly different query formatting, comments in SQL, or more complex subqueries. It violates the Single Responsibility Principle. Database interaction logic should be clear and intent-based, not inferred from string parsing.
    **Line(s) to Fix:** 40-44
    **Current Code:**
    ```javascript
      if (sql.trim().toLowerCase().startsWith("select")) {
        if (sql.toLowerCase().includes("limit 1")) {
          return stmt.get(params); // single row
        }
        return stmt.all(params); // multiple rows
      }
      // ...
      return stmt.run(params);
    ```
    **Suggested Fix:**
    ```javascript
    // Break down the generic 'runQuery' into more specific, intent-based functions:

    export function selectOne(sql, params = []) {
      try {
        const stmt = db.prepare(sql);
        return stmt.get(params); // Fetches a single row
      } catch (error) {
        console.error("Database selectOne failed:", error); // Use console.error for errors
        throw new ApiError(500, "Database selectOne failed", [error.message]);
      }
    }

    export function selectAll(sql, params = []) {
      try {
        const stmt = db.prepare(sql);
        return stmt.all(params); // Fetches multiple rows
      } catch (error) {
        console.error("Database selectAll failed:", error);
        throw new ApiError(500, "Database selectAll failed", [error.message]);
      }
    }

    export function runCommand(sql, params = []) { // Renamed from runQuery for clarity on its purpose
      try {
        const stmt = db.prepare(sql);
        return stmt.run(params); // Executes INSERT/UPDATE/DELETE
      } catch (error) {
        console.error("Database command failed:", error);
        throw new ApiError(500, "Database command failed", [error.message]);
      }
    }
    // Remove the original generic runQuery function, or simplify it to only handle run() if needed,
    // then ensure all callers use the appropriate new function (selectOne, selectAll, runCommand).
    ```
    **Priority:** HIGH

**Line(s):** 47
-   **Issue Type:** STYLE / MAINTAINABILITY
    **Description:** Commented-out code, like `//console.log(stmt.run(params));`, should generally be removed before merging code to the main branch. It adds clutter, can confuse future readers about its purpose, and version control (Git) is designed to keep a history of changes, making commented-out code redundant.
    **Line(s) to Fix:** 47
    **Current Code:** `//console.log(stmt.run(params));`
    **Suggested Fix:** `// Remove this line.`
    **Priority:** LOW

**File:** `server/src/controllers/upload.controller.js`

**Line(s):** 7
-   **Issue Type:** LOGIC / MAINTAINABILITY
    **Description:** If the `runQuery` function in `sqlLite.db.js` is refactored into `selectOne`, `selectAll`, and `runCommand` as suggested, the import statement here will need to be updated to reflect the new exported functions.
    **Line(s) to Fix:** 7
    **Current Code:** `import { db, runQuery } from "../database/sqlLite.db.js";`
    **Suggested Fix:** `import { db, selectOne, runCommand } from "../database/sqlLite.db.js"; // Adjust imports based on new DB functions`
    **Priority:** MEDIUM

**Line(s):** 11-13
-   **Issue Type:** BUG / LOGIC
    **Description:** The `runQuery` function is likely asynchronous (it performs database operations), but the call to it is missing the `await` keyword. As a result, `user` will be assigned a Promise object instead of the resolved user data. This leads to incorrect behavior when `user` or its properties are accessed later in the code.
    **Line(s) to Fix:** 11-13
    **Current Code:**
    ```javascript
    const user = runQuery("SELECT userId FROM userData WHERE email = ? LIMIT 1", [
        req.user.email,
    ]);
    ```
    **Suggested Fix:**
    ```javascript
    const user = await selectOne("SELECT userId FROM userData WHERE email = ? LIMIT 1", [
        req.user.email,
    ]); // Use await and the specific 'selectOne' function
    ```
    **Priority:** HIGH

**Line(s):** 14
-   **Issue Type:** STYLE / DEBUGGING
    **Description:** Using `console.log` for debugging information like "User found" is not suitable for production. It clutters logs and lacks proper log level management. The imported `logger` utility should be used instead.
    **Line(s) to Fix:** 14
    **Current Code:** `console.log("User found:", user);`
    **Suggested Fix:** `logger.debug("User found:", user); // Use logger for better log management`
    **Priority:** LOW

**Line(s):** 19
-   **Issue Type:** BUG / LOGIC
    **Description:** Due to the missing `await` on line 11, `user` is a Promise object. A Promise object, even if it will eventually resolve to `null` or `undefined`, is a truthy value in JavaScript. Therefore, `if (!user)` will always evaluate to `false` and the `ApiError` will never be thrown, even when a user is genuinely not found. This hides errors and will lead to crashes when attempting to access `user.userId` later.
    **Line(s) to Fix:** 19
    **Current Code:** `if (!user) {`
    **Suggested Fix:** (This issue is resolved by correctly `await`ing `selectOne` on line 11-13. Once awaited, `user` will correctly be `null` or `undefined` if no record is found, making this check functional).
    **Priority:** HIGH

**Line(s):** 47
-   **Issue Type:** BUG / LOGIC / DATA INTEGRITY
    **Description:** The `userId` is hardcoded as `1` in the `INSERT INTO files` statement. This means that regardless of which user uploads the file, it will always be associated with `userId` 1, leading to incorrect data attribution and data integrity issues. The actual `userId` from the authenticated user (obtained via `req.user.email` and the database lookup) should be used.
    **Line(s) to Fix:** 47-50
    **Current Code:**
    ```javascript
    runQuery(
      `
    INSERT INTO files (userId, filePath, vectorId)
    VALUES (?, ?, ?)
    `,
      [1, req.file.path, vectorResult.id]
    );
    ```
    **Suggested Fix:**
    ```javascript
    await runCommand( // Use await and the specific 'runCommand' function
      `
    INSERT INTO files (userId, filePath, vectorId)
    VALUES (?, ?, ?)
    `,
      [user.userId, req.file.path, vectorResult.id] // Use the actual user ID
    );
    ```
    **Priority:** HIGH

**Line(s):** 55
-   **Issue Type:** STYLE / MAINTAINABILITY
    **Description:** Commented-out code should generally be removed from the codebase before merging. It clutters the file and version control systems (like Git) are designed to track history, making commented-out code redundant.
    **Line(s) to Fix:** 55
    **Current Code:** `// console.log("✅ File inserted with ID:", fileInsert.lastInsertRowid);`
    **Suggested Fix:** `// Remove this line.`
    **Priority:** LOW

**File:** `server/uploads/MS Word Basics-119389542.pdf`
**Line(s)::** N/A
-   **Issue Type:** N/A
    **Description:** This is a binary file (PDF) and falls outside the scope of a code review.
    **Line(s) to Fix:** N/A
    **Current Code:** N/A
    **Suggested Fix:** N/A
    **Priority:** N/A

### Summary Section
**Overall Review Summary:**
-   **Total Issues Found:** 13
-   **Critical Issues:** 5 (Security, Major Bugs, Architectural)
-   **Code Quality Score:** 3/10
-   **Approval Status:** NEEDS_CHANGES
-   **Key Recommendations:**
    1.  **Critical Security Fix**: Implement robust password hashing (e.g., bcrypt, Argon2) *before* storing user passwords in the database. Plain text password storage is a severe vulnerability.
    2.  **Architectural Refinement & Asynchronous Logic Correction**: Refactor the generic `runQuery` function into more specific, intent-driven asynchronous database interaction methods (e.g., `selectOne`, `selectAll`, `runCommand`). Crucially, ensure all calls to these asynchronous functions are correctly `await`ed to prevent `Promise` objects being used where data is expected, which currently leads to critical bugs.
    3.  **Data Integrity & Dynamic Value Usage**: Replace hardcoded values (e.g., `userId: 1`) with dynamically retrieved data (e.g., `user.userId`) in database insert operations to ensure data integrity and correct attribution.
```