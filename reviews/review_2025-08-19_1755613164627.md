**File:** server/src/controllers/auth.controller.js

**Line(s):** 4-5
- **Issue Type:** STYLE/MAINTAINABILITY
  **Description:** The imports for `success` from `zod` and `da` from `zod/v4/locales` are declared but not used anywhere in the `auth.controller.js` file. Unused imports clutter the codebase and can indicate remnants of refactoring or incomplete features. They should be removed to improve code readability and maintainability.
  **Line(s) to Fix:** 4-5
  **Current Code:**
  ```javascript
  import { success } from "zod";
  import { da } from "zod/v4/locales";
  ```
  **Suggested Fix:**
  ```javascript
  // Remove these lines
  ```
  **Priority:** LOW

**Line(s):** 9
- **Issue Type:** STYLE
  **Description:** This `console.log(req.body);` statement is debug output. It should be removed from production code to avoid unnecessary log noise and potential exposure of sensitive request body data in server logs.
  **Line(s) to Fix:** 9
  **Current Code:** `console.log(req.body);`
  **Suggested Fix:** `// Remove this line`
  **Priority:** LOW

**Line(s):** 17, 32, 71
- **Issue Type:** BUG/PERFORMANCE/LOGIC
  **Description:** Database operations performed by `runQuery` are typically asynchronous. Calling `runQuery` without `await` means that the subsequent code (e.g., `existingUser.length` or `user.length`) will operate on a Promise object instead of the actual query results. This will lead to incorrect logic (e.g., `Promise.length` being `undefined` or a non-zero value depending on JS engine specifics, but not the number of results). It also fails to properly handle the asynchronous nature of database interactions, which can lead to race conditions or incorrect data processing. All calls to `runQuery` should be `await`ed.
  **Line(s) to Fix:** 17, 32, 71
  **Current Code:**
  ```javascript
  const existingUser = runQuery(`SELECT * FROM userData WHERE email = ?`, [ email, ]);
  // ...
  const newUser = await runQuery(`INSERT INTO userData (name, email, password) VALUES (?, ?, ?)`, [name, email, hashedPassword]);
  // ...
  const user = runQuery(`SELECT * FROM userData WHERE email = ?`, [email]);
  ```
  **Suggested Fix:**
  ```javascript
  const existingUser = await runQuery(`SELECT * FROM userData WHERE email = ?`, [ email, ]);
  // ...
  const newUser = await runQuery(`INSERT INTO userData (name, email, password) VALUES (?, ?, ?)`, [name, email, hashedPassword]); // This one already has await, but needs review for consistency if `runQuery` itself isn't awaited elsewhere. Given the previous analysis on `jwtMaker.js` it's likely meant to be awaited.
  // ...
  const user = await runQuery(`SELECT * FROM userData WHERE email = ?`, [email]);
  ```
  **Priority:** HIGH

**Line(s):** 20
- **Issue Type:** STYLE
  **Description:** This line contains commented-out debug code (`//console.log(existingUser);`). It should be removed to keep the codebase clean and avoid confusion for future developers.
  **Line(s) to Fix:** 20
  **Current Code:** `//console.log(existingUser);`
  **Suggested Fix:** `// Remove this line`
  **Priority:** LOW

**Line(s):** 82, 86
- **Issue Type:** LOGIC/CONSISTENCY/MAINTAINABILITY
  **Description:** The `createJwtToken` function is called differently in `handleUserSignUp` (line 40) where it's destructured to `{ accessToken, refreshToken }`, implying it returns an object with these properties. However, in `handleUserLogin`, the return value is assigned directly to a single variable `token`. This leads to `token` being an object `{ accessToken, refreshToken }` rather than a single string token. Consequently, the response on line 86 (`data: { token }`) results in a double-nested object (`data: { token: { accessToken: "...", refreshToken: "..." } }`). This is inconsistent with standard JWT flow where usually an `accessToken` and optionally a `refreshToken` are directly exposed in the data payload, not nested inside another `token` object. It also makes the API response less intuitive and harder to consume.
  **Line(s) to Fix:** 82, 86
  **Current Code:**
  ```javascript
  // Line 82
  const token = createJwtToken(user[0].email, user[0].userId);
  // ...
  // Line 86
  .json({ success: true, data: { token }, message: "Login successful" });
  ```
  **Suggested Fix:**
  ```javascript
  // Line 82
  const { accessToken, refreshToken } = createJwtToken(user[0].email, user[0].userId);
  // ...
  // Line 86
  .json({ success: true, data: { accessToken, refreshToken }, message: "Login successful" }); // Or just { accessToken } if refreshToken is handled via cookie
  ```
  **Priority:** HIGH

**Line(s):** 45-48
- **Issue Type:** MAINTAINABILITY/SECURITY
  **Description:** The cookie configuration uses `secure: true` and `sameSite: "strict"`. While `secure: true` is crucial for production environments to ensure cookies are only sent over HTTPS, it will prevent the cookie from being set if the application is running locally over HTTP (e.g., `localhost`). This can lead to unexpected behavior during development. Consider using an environment variable to conditionally set `secure: process.env.NODE_ENV === 'production'`. `sameSite: "strict"` is excellent for security (CSRF protection) but can sometimes be overly restrictive, though generally recommended. Document this requirement.
  **Line(s) to Fix:** 45-48
  **Current Code:**
  ```javascript
  res.cookie("refreshToken", refreshToken, {
    httpOnly: true,
    secure: true, // Only send cookie over HTTPS
    sameSite: "strict", // Protect against CSRF attacks
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
  });
  ```
  **Suggested Fix:**
  ```javascript
  res.cookie("refreshToken", refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production', // Set to true only in production
    sameSite: "strict",
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
  });
  // Add a comment to the PR or code about required HTTPS for production deployment.
  ```
  **Priority:** MEDIUM

---

**Overall Review Summary:**
- **Total Issues Found:** 6
- **Critical Issues:** 2 (Incorrect handling of asynchronous DB calls, inconsistent and incorrect JWT response structure)
- **Code Quality Score:** 6/10
- **Approval Status:** NEEDS_CHANGES
- **Key Recommendations:**
    1.  **Critical Fix: Asynchronous Operations:** Ensure all `runQuery` calls are `await`ed to correctly handle database operations and prevent logical errors caused by Promise objects being used as results.
    2.  **Critical Fix: JWT Response Consistency:** Align the `handleUserLogin`'s JWT response to match `handleUserSignUp` by explicitly returning and consuming `accessToken` and `refreshToken` properties from `createJwtToken`, rather than nesting the entire object.
    3.  **Code Cleanliness:** Remove all unused imports, `console.log` statements, and commented-out code to maintain a clean and professional codebase.