### File-by-File Review

**File:** `server/src/database/sqlLite.db.js`
**Line(s):** 4
-   **Issue Type:** MAINTAINABILITY
    **Description:** The database file path is hardcoded. This makes the application inflexible for different deployment environments (e.g., development, testing, production) where different database instances or paths might be required. It's best practice to manage such configurations using environment variables.
    **Line(s) to Fix:** 4
    **Current Code:** `export const db = new Database("mydb.sqlite");`
    **Suggested Fix:** `export const db = new Database(process.env.DATABASE_PATH || "mydb.sqlite"); // Use an environment variable for configuration`
    **Priority:** MEDIUM

**Line(s):** 5
-   **Issue Type:** STYLE / MAINTAINABILITY
    **Description:** Using `console.log` for informational messages like the database path is generally not recommended for production environments. For better log management, filtering, and destination control, a dedicated logging library (e.g., Winston, Pino, or a custom logger wrapper) should be used, typically at an 'info' or 'debug' level.
    **Line(s) to Fix:** 5
    **Current Code:** `console.log(`Database path: ${db.name}`);`
    **Suggested Fix:** `// Consider integrating a proper logging library (e.g., Winston, Pino) and use it here:\n// logger.info(\`Database path: \${db.name}\`);`
    **Priority:** LOW

**Line(s):** 8, 19, 30
-   **Issue Type:** STYLE / MAINTAINABILITY
    **Description:** Comments are written in Hindi. For broader collaboration, open-source contributions, or future maintainers, English is the universally accepted standard for code comments in professional software development. Consistency in language improves readability and maintainability.
    **Line(s) to Fix:** 8, 19, 30
    **Current Code:**
    ```javascript
    // Agar table pehle se nahi hai to ek dummy bana dete hain
    // Agar query SELECT hai to all() ya get() use karenge
    // INSERT/UPDATE/DELETE ke liye run()
    ```
    **Suggested Fix:**
    ```javascript
    // If the table does not exist, create it
    // For SELECT queries, use all() or get()
    // Use run() for INSERT/UPDATE/DELETE queries
    ```
    **Priority:** MEDIUM

**Line(s):** 11, 23, 33
-   **Issue Type:** PERFORMANCE / BEST PRACTICE
    **Description:** In SQLite, a column defined as `INTEGER PRIMARY KEY` automatically implies auto-incrementing behavior (it becomes an alias for the internal `ROWID` and is guaranteed to be unique and increasing). Explicitly adding `AUTOINCREMENT` introduces a small overhead (slower performance, larger database files) by preventing the reuse of ROWIDs from deleted rows. It is rarely needed unless strict non-reusing of IDs is a specific requirement (e.g., for syncing with external systems), which is not typical for most applications.
    **Line(s) to Fix:** 11, 23, 33
    **Current Code:**
    ```sql
    userId INTEGER PRIMARY KEY AUTOINCREMENT,
    chatId INTEGER PRIMARY KEY AUTOINCREMENT,
    fileId INTEGER PRIMARY KEY AUTOINCREMENT,
    ```
    **Suggested Fix:**
    ```sql
    userId INTEGER PRIMARY KEY,
    -- For chats table
    chatId INTEGER PRIMARY KEY,
    -- For files table
    fileId INTEGER PRIMARY KEY,
    ```
    **Priority:** MEDIUM

**Line(s):** 14
-   **Issue Type:** SECURITY
    **Description:** Storing user passwords directly as plain text (`password TEXT NOT NULL`) is a critical security vulnerability. If the database is ever compromised, all user passwords would be exposed, leading to severe risks like identity theft and credential stuffing attacks. Passwords must always be hashed using a strong, one-way, and computationally expensive hashing algorithm (e.g., bcrypt, Argon2) before storage. This hashing *must* be handled in the application logic before saving the password to the database.
    **Line(s) to Fix:** 14
    **Current Code:** `password TEXT NOT NULL,`
    **Suggested Fix:**
    ```sql
    -- The database schema itself might not change the `TEXT` type, but the
    -- *application logic* must ensure that a strong hash of the password
    -- (e.g., bcrypt hash) is stored here, NOT the plain text password.
    password TEXT NOT NULL -- This column MUST store strong password hashes (e.g., bcrypt), NOT plain text!
    ```
    **Priority:** HIGH

**Line(s):** 18
-   **Issue Type:** MAINTAINABILITY / STYLE
    **Description:** There's inconsistent logging for table creation. Only the "Users table created or already exists." message is logged, while similar messages are missing for the "Chats" and "Files" tables. For better clarity and debugging during application startup, it's good practice to consistently log the status of all significant initialization steps.
    **Line(s) to Fix:** 18
    **Current Code:** `console.log("Users table created or already exists.");`
    **Suggested Fix:**
    ```javascript
    console.log("Users table created or already exists.");
    console.log("Chats table created or already exists.");
    console.log("Files table created or already exists.");
    ```
    **Priority:** LOW

**Line(s):** 40-44
-   **Issue Type:** LOGIC / MAINTAINABILITY / ARCHITECTURE
    **Description:** The `runQuery` function attempts to be generic but uses brittle string-matching (`.startsWith("select")` and `.includes("limit 1")`) to determine the database operation (single row, multiple rows, or command). This approach is fragile; it can break with slightly different query formatting, comments in SQL, or more complex subqueries. It violates the Single Responsibility Principle. Database interaction logic should be clear and intent-based, not inferred from string parsing. Furthermore, database operations are inherently asynchronous and should be handled with `async/await` patterns for clarity and correct execution flow.
    **Line(s) to Fix:** 40-44
    **Current Code:**
    ```javascript
      if (sql.trim().toLowerCase().startsWith("select")) {
        if (sql.toLowerCase().includes("limit 1")) {
          return stmt.get(params); // single row
        }
        return stmt.all(params); // multiple rows
      }
      // ...
      return stmt.run(params);
    ```
    **Suggested Fix:**
    ```javascript
    // Break down the generic 'runQuery' into more specific, intent-based functions.
    // Ensure all these functions are `async` and use `await` internally if `db.prepare`
    // or `stmt.get/all/run` were truly asynchronous (better-sqlite3 is synchronous by default
    // unless configured with async wrappers, but it's good practice to mark as async
    // if a wrapper for promises is used or if this abstraction layer is intended for async operations).
    // Assuming a Promise-based wrapper for better-sqlite3 is used or will be used for consistency:

    export async function selectOne(sql, params = []) {
      try {
        const stmt = db.prepare(sql);
        return await stmt.get(params); // Fetches a single row
      } catch (error) {
        console.error("Database selectOne failed:", error); // Use console.error for errors
        throw new ApiError(500, "Database selectOne failed", [error.message]);
      }
    }

    export async function selectAll(sql, params = []) {
      try {
        const stmt = db.prepare(sql);
        return await stmt.all(params); // Fetches multiple rows
      } catch (error) {
        console.error("Database selectAll failed:", error);
        throw new ApiError(500, "Database selectAll failed", [error.message]);
      }
    }

    export async function runCommand(sql, params = []) { // Renamed from runQuery for clarity on its purpose
      try {
        const stmt = db.prepare(sql);
        return await stmt.run(params); // Executes INSERT/UPDATE/DELETE
      } catch (error) {
        console.error("Database command failed:", error);
        throw new ApiError(500, "Database command failed", [error.message]);
      }
    }
    // Remove the original generic runQuery function.
    // All callers should now use the appropriate new function (selectOne, selectAll, runCommand).
    ```
    **Priority:** HIGH

**Line(s):** 47
-   **Issue Type:** STYLE / MAINTAINABILITY
    **Description:** Commented-out code, like `//console.log(stmt.run(params));`, should generally be removed before merging code to the main branch. It adds clutter, can confuse future readers about its purpose, and version control (Git) is designed to keep a history of changes, making commented-out code redundant.
    **Line(s) to Fix:** 47
    **Current Code:** `//console.log(stmt.run(params));`
    **Suggested Fix:** `// Remove this line.`
    **Priority:** LOW

**File:** `server/src/controllers/upload.controller.js`

**Line(s):** 7
-   **Issue Type:** LOGIC / MAINTAINABILITY
    **Description:** If the `runQuery` function in `sqlLite.db.js` is refactored into `selectOne`, `selectAll`, and `runCommand` as suggested, the import statement here will need to be updated to reflect the new exported functions.
    **Line(s) to Fix:** 7
    **Current Code:** `import { db, runQuery } from "../database/sqlLite.db.js";`
    **Suggested Fix:** `import { db, selectOne, runCommand } from "../database/sqlLite.db.js"; // Adjust imports based on new DB functions`
    **Priority:** MEDIUM

**Line(s):** 11-13
-   **Issue Type:** BUG / LOGIC
    **Description:** The `runQuery` function (or its suggested replacement `selectOne`) performs an asynchronous database operation. The call to it is missing the `await` keyword. As a result, `user` will be assigned a Promise object instead of the resolved user data. This leads to incorrect behavior when `user` or its properties are accessed later in the code (e.g., `user.userId`).
    **Line(s) to Fix:** 11-13
    **Current Code:**
    ```javascript
    const user = runQuery("SELECT userId FROM userData WHERE email = ? LIMIT 1", [
        req.user.email,
    ]);
    ```
    **Suggested Fix:**
    ```javascript
    const user = await selectOne("SELECT userId FROM userData WHERE email = ? LIMIT 1", [
        req.user.email,
    ]); // Use await and the specific 'selectOne' function
    ```
    **Priority:** HIGH

**Line(s):** 14
-   **Issue Type:** STYLE / DEBUGGING
    **Description:** Using `console.log` for debugging information like "User found" is not suitable for production. It clutters logs and lacks proper log level management. It is best practice to use a dedicated logging utility (e.g., `logger` which seems to be intended for this project, or a library like Winston/Pino) with appropriate log levels (e.g., `debug`).
    **Line(s) to Fix:** 14
    **Current Code:** `console.log("User found:", user);`
    **Suggested Fix:** `logger.debug("User found:", user); // Use imported logger for better log management`
    **Priority:** LOW

**Line(s):** 19
-   **Issue Type:** BUG / LOGIC
    **Description:** Due to the missing `await` on lines 11-13, `user` is a Promise object. A Promise object, even if it will eventually resolve to `null` or `undefined`, is a truthy value in JavaScript. Therefore, `if (!user)` will always evaluate to `false` and the `ApiError` will never be thrown, even when a user is genuinely not found. This hides errors, prevents proper authentication/authorization, and will lead to subsequent crashes when attempting to access `user.userId` (e.g., on line 49).
    **Line(s) to Fix:** 19
    **Current Code:** `if (!user) {`
    **Suggested Fix:** (This issue is resolved by correctly `await`ing `selectOne` on lines 11-13. Once `user` is correctly awaited, it will be `null` or `undefined` if no record is found, making this `if (!user)` check functional and correctly throwing the `ApiError`).
    **Priority:** HIGH

**Line(s):** 47-50
-   **Issue Type:** BUG / LOGIC / DATA INTEGRITY
    **Description:** The `userId` is hardcoded as `1` in the `INSERT INTO files` statement. This means that regardless of which user uploads the file, it will always be associated with `userId` 1, leading to incorrect data attribution and severe data integrity issues. The actual `userId` from the authenticated user (which should have been obtained via `req.user.email` and the preceding database lookup on line 11) must be used here. This also needs to be `await`ed and use the correct database function.
    **Line(s) to Fix:** 47-50
    **Current Code:**
    ```javascript
    runQuery(
      `
    INSERT INTO files (userId, filePath, vectorId)
    VALUES (?, ?, ?)
    `,
      [1, req.file.path, vectorResult.id]
    );
    ```
    **Suggested Fix:**
    ```javascript
    await runCommand( // Use await and the specific 'runCommand' function
      `
    INSERT INTO files (userId, filePath, vectorId)
    VALUES (?, ?, ?)
    `,
      [user.userId, req.file.path, vectorResult.id] // Use the actual user ID obtained from line 11
    );
    ```
    **Priority:** HIGH

**Line(s):** 55
-   **Issue Type:** STYLE / MAINTAINABILITY
    **Description:** Commented-out code should generally be removed from the codebase before merging. It clutters the file and makes the code harder to read. Version control systems (like Git) are designed to track changes and history, making commented-out code redundant.
    **Line(s) to Fix:** 55
    **Current Code:** `// console.log("âœ… File inserted with ID:", fileInsert.lastInsertRowid);`
    **Suggested Fix:** `// Remove this line.`
    **Priority:** LOW

**File:** `server/uploads/MS Word Basics-119389542.pdf`
**Line(s)::** N/A
-   **Issue Type:** N/A
    **Description:** This is a binary file (PDF) and falls outside the scope of a code review.
    **Line(s) to Fix:** N/A
    **Current Code:** N/A
    **Suggested Fix:** N/A
    **Priority:** N/A

**File:** `server/uploads/MS Word Basics-928671977.pdf`
**Line(s)::** N/A
-   **Issue Type:** N/A
    **Description:** This is a binary file (PDF) and falls outside the scope of a code review.
    **Line(s) to Fix:** N/A
    **Current Code:** N/A
    **Suggested Fix:** N/A
    **Priority:** N/A

### Summary Section
**Overall Review Summary:**
-   **Total Issues Found:** 13
-   **Critical Issues:** 5 (Security, Major Bugs, Architectural)
-   **Code Quality Score:** 3/10
-   **Approval Status:** NEEDS_CHANGES
-   **Key Recommendations:**
    1.  **Critical Security Fix (Password Hashing)**: Implement robust password hashing (e.g., bcrypt, Argon2) *before* storing user passwords in the database. Storing plain text passwords is a severe and unacceptable security vulnerability.
    2.  **Architectural Refinement & Asynchronous Logic Correction**: Refactor the generic `runQuery` function into more specific, intent-driven asynchronous database interaction methods (e.g., `selectOne`, `selectAll`, `runCommand`). Crucially, ensure all calls to these asynchronous functions are correctly `await`ed to prevent `Promise` objects from being used where actual data is expected, which currently leads to critical bugs and hidden errors.
    3.  **Data Integrity & Dynamic Value Usage**: Replace hardcoded `userId` (e.g., `1`) with the dynamically retrieved and validated `user.userId` in database insert/update operations to ensure correct data attribution and maintain data integrity.